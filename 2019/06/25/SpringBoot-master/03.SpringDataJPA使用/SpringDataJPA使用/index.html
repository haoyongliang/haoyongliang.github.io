<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>虫虫爬丫爬</title><meta name="description" content><meta name="keywords" content><meta name="author" content="郝永亮"><meta name="copyright" content="郝永亮"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://haoyongliang.gitee.io/2019/06/25/SpringBoot-master/03.SpringDataJPA使用/SpringDataJPA使用/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content><meta name="twitter:description" content><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content><meta property="og:url" content="https://haoyongliang.gitee.io/2019/06/25/SpringBoot-master/03.SpringDataJPA使用/SpringDataJPA使用/"><meta property="og:site_name" content="虫虫爬丫爬"><meta property="og:description" content><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="分布式RPC框架Apache Dubbo" href="https://haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/"><link rel="next" title href="https://haoyongliang.gitee.io/2019/06/25/SpringBoot-master/02.web开发实战/web开发实战/"><link rel="manifest" href="/img/pwa/manifest.json"><meta name="theme-color" content="#fff"><meta name="msapplication-TileColor" content="#fff"><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: undefined,
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Boot技术栈-Spring-Data-JPA"><span class="toc-number">1.</span> <span class="toc-text">Spring Boot技术栈(Spring Data JPA)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Spring-Data-JPA介绍"><span class="toc-number">2.</span> <span class="toc-text">1.Spring Data JPA介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-开发环境搭建"><span class="toc-number">3.</span> <span class="toc-text">2.开发环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-添加依赖"><span class="toc-number">3.1.</span> <span class="toc-text">1.添加依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-修改application-properties"><span class="toc-number">3.2.</span> <span class="toc-text">2.修改application.properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-创建实体类"><span class="toc-number">3.3.</span> <span class="toc-text">3.创建实体类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-创建DAO"><span class="toc-number">3.4.</span> <span class="toc-text">4.创建DAO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-编写测试代码"><span class="toc-number">3.5.</span> <span class="toc-text">5.编写测试代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-常见数据库操作"><span class="toc-number">4.</span> <span class="toc-text">3.常见数据库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-基本查询"><span class="toc-number">4.1.</span> <span class="toc-text">1.基本查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-自定义简单查询"><span class="toc-number">4.2.</span> <span class="toc-text">2.自定义简单查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-分页查询"><span class="toc-number">4.3.</span> <span class="toc-text">3.分页查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-查询前N条数据"><span class="toc-number">4.4.</span> <span class="toc-text">4.查询前N条数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-自定义-SQL-查询"><span class="toc-number">4.5.</span> <span class="toc-text">5.自定义 SQL 查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-自定义SQL-更新或删除数据"><span class="toc-number">4.6.</span> <span class="toc-text">6.自定义SQL 更新或删除数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-一对多关系-oneToMany"><span class="toc-number">4.7.</span> <span class="toc-text">7.一对多关系(oneToMany)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试代码"><span class="toc-number">4.7.1.</span> <span class="toc-text">测试代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-多对一关系-ManyToOne"><span class="toc-number">4.8.</span> <span class="toc-text">8.多对一关系(ManyToOne)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-多对多关系-ManyToMany"><span class="toc-number">4.9.</span> <span class="toc-text">9.多对多关系(ManyToMany)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试代码-1"><span class="toc-number">4.9.1.</span> <span class="toc-text">测试代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#人类-Person"><span class="toc-number">4.9.2.</span> <span class="toc-text">人类(Person)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试类"><span class="toc-number">4.9.3.</span> <span class="toc-text">测试类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附录"><span class="toc-number">5.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OneToOne注解"><span class="toc-number">5.1.</span> <span class="toc-text">@OneToOne注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OneToMany注解"><span class="toc-number">5.2.</span> <span class="toc-text">@OneToMany注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ManyToOne注解"><span class="toc-number">5.3.</span> <span class="toc-text">@ManyToOne注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JoinTable注解"><span class="toc-number">5.4.</span> <span class="toc-text">@JoinTable注解</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">虫虫爬丫爬</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">无题</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-06-25<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2018-05-22</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Spring-Boot技术栈-Spring-Data-JPA"><a href="#Spring-Boot技术栈-Spring-Data-JPA" class="headerlink" title="Spring Boot技术栈(Spring Data JPA)"></a>Spring Boot技术栈(Spring Data JPA)</h1><blockquote>
<p>本篇介绍 通过Spring Data JPA对数据库进行常见的操作:删除、修改、添加、条件查询、分页查询、单表查询、多表查询。</p>
</blockquote>
<h1 id="1-Spring-Data-JPA介绍"><a href="#1-Spring-Data-JPA介绍" class="headerlink" title="1.Spring Data JPA介绍"></a>1.Spring Data JPA介绍</h1><ul>
<li>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！</li>
<li>Spring Data JPA 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现。</li>
</ul>
<h1 id="2-开发环境搭建"><a href="#2-开发环境搭建" class="headerlink" title="2.开发环境搭建"></a>2.开发环境搭建</h1><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.Springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-修改application-properties"><a href="#2-修改application-properties" class="headerlink" title="2.修改application.properties"></a>2.修改application.properties</h2><p>添加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#数据库连接URL</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/heima</span><br><span class="line">#数据库帐号</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">#数据库密码</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">#驱动名 </span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">#每次hibernate 时根据 model 类自动更新表结构</span><br><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br><span class="line">#告诉Hibernate，将HQL翻译成哪种数据库的SQL</span><br><span class="line">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">#是否在控制台打印SQL语句,测试时设置为true</span><br><span class="line">spring.jpa.show-sql= true</span><br></pre></td></tr></table></figure>

<p>配置文件说明</p>
<blockquote>
<ol>
<li>spring.jpa.properties.hibernate.hbm2ddl.auto : 自动创建 | 更新 | 验证数据库表结构<ul>
<li>create : 每次加载hibernate，如果数据库中存在表，将所有表删除，然后重新生成表</li>
<li>update 每次hibernate 时根据 model 类自动更新表结构，如果是第一次则创建表结构。之前表数据不会删除</li>
<li>validate : 设置为validate:加载hibernate时，验证创建数据库表结构，这样 spring在加载之初，如果model层和数据库表结构不同，就会报错，这样有助于技术运维预先发现问题。例如：ProductInfoEntity这个实体有property1这个属性，而对应的数据库表product没有property1这个字段，就会在tomcat启动的时候报错：错误可能如下：Missing column: property1 in wjs.product</li>
<li>create-drop : 如果一开始数据库没有表，启动tomcat的时候会生成表，当把tomcat关闭之后生成的表又会消除</li>
</ul>
</li>
<li>spring.jpa.properties.hibernate.dialect ： 告诉Hibernate，将HQL翻译成哪种数据库的SQL,常见的有<ul>
<li>mysql : org.hibernate.dialect.MySQLDialect</li>
<li>oracle : org.hibernate.dialect.OracleDialect</li>
<li>sqlserver : org.hibernate.dialect.SQLServerDialect</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="3-创建实体类"><a href="#3-创建实体类" class="headerlink" title="3.创建实体类"></a>3.创建实体类</h2><ul>
<li>注意：<ul>
<li>实体类在命名时候不要用数据库中的关键字比如Order,可以定义成Orders<ul>
<li>Entity 中不映射成列的字段得加 @Transient 注解，不加注解也会映射成列</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	账户</span><br><span class="line">*/</span><br><span class="line">@Entity</span><br><span class="line">public class Account implements Serializable&#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;		//ID主键</span><br><span class="line">    @Column(nullable = false,unique = true)</span><br><span class="line">    private String username;//用户名,不能为空，不能重复</span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private String password;//密码，不能为空</span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private String gender;  //性别，不能为空</span><br><span class="line">    @Column()</span><br><span class="line">    private String address; //地址</span><br><span class="line">    @Column()</span><br><span class="line">    private double balance;	//账户余额</span><br><span class="line">    </span><br><span class="line">    public Account(String username, String password, String gender, String address, double balance) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">        this.address = address;</span><br><span class="line">        this.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    //省略无参构造,getter,setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-创建DAO"><a href="#4-创建DAO" class="headerlink" title="4.创建DAO"></a>4.创建DAO</h2><p> Dao 只要继承 JpaRepository 类就可以，几乎可以不用写方法，还有一个特别有个性的功能非常赞，就是可以根据方法名来自动的生产 SQL，如 findByUserName 会自动生产一个以 userName 为参数的查询方法，如 findAll 自动会查询表里面的所有数据，如自动分页等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface AccountRepository extends JpaRepositoryAccount,Long &#123;</span><br><span class="line">    Account findAccountByUsername(String username);</span><br><span class="line">    List&lt;Account&gt; findAllByAddressLike(String address);//比如查询地址包含&quot;西&quot;的 address的值=&quot;%西%&quot;</span><br><span class="line">    List&lt;Account&gt; findAllByBalanceGreaterThanEqual(double balance);//余额大于等于指定金额</span><br><span class="line">    List&lt;Account&gt; findAllByBalanceGreaterThan(double balance);//余额大于指定金额</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：JpaRepository&lt;T,ID&gt;这个接口只是一个空的接口，目的是为了统一所有Repository的类型，其接口类型使用了泛型，泛型参数中T代表实体类型，ID则是实体中id的类型</li>
</ul>
<h2 id="5-编写测试代码"><a href="#5-编写测试代码" class="headerlink" title="5.编写测试代码"></a>5.编写测试代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class AccountRepositoryTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountRepository accountRepository;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()  &#123;</span><br><span class="line">    accountRepository.deleteAll();</span><br><span class="line">    accountRepository.save(new Account(&quot;张三丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西太原&quot;,5000.5));</span><br><span class="line">    accountRepository.save(new Account(&quot;张四丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西临汾&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;张五丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西忻州&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;小明&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北承德&quot;,3000));</span><br><span class="line">    accountRepository.save(new Account(&quot;小丽&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北保定&quot;,9000.5));</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(5,accountRepository.findAll().size());//如果查询结果等于5</span><br><span class="line">    Assert.assertEquals(3,accountRepository.findAllByAddressLike(&quot;%西%&quot;).size());//地址中包含西的记录</span><br><span class="line">    Assert.assertEquals(3,accountRepository.findAllByBalanceGreaterThanEqual(3000).size());//大于等于3000的余额的记录</span><br><span class="line">    Assert.assertEquals(2,accountRepository.findAllByBalanceGreaterThan(3000).size());//大于3000的余额的记录</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##6.运行时报错及解决方案</p>
<p>可能出现异常：</p>
<ol>
<li>Caused by: java.lang.IllegalArgumentException: Not a managed type: class com.nsun.study.dao.model.UserInfo<br>at org.hibernate.jpa.internal.metamodel.MetamodelImpl.managedType(MetamodelImpl.java:210)</li>
<li>Consider defining a bean of type ‘*Repository’ in your configuration. </li>
</ol>
<p>原因：启动时没有扫描实体类和DAO,导致没有注入</p>
<p>解决方案：在Application 增加注解(测试类也添加)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EntityScan(basePackages=&quot;cn.itcast.sprintBootDemo.domain&quot;)</span><br><span class="line">@EnableJpaRepositories(basePackages = &#123;&quot;cn.itcast.sprintBootDemo.repository&quot;&#125;)</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class SprintBootDemoApplication &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SprintBootDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-常见数据库操作"><a href="#3-常见数据库操作" class="headerlink" title="3.常见数据库操作"></a>3.常见数据库操作</h1><blockquote>
<p>基本查询也分为两种，一种是 Spring Data 默认已经实现，一种是根据查询的方法来自动解析成 SQL。</p>
</blockquote>
<h2 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="1.基本查询"></a>1.基本查询</h2><blockquote>
<p>Spring Data JPA 默认预先生成了一些基本的 CURD 的方法，如增加，删除，修改，查询</p>
</blockquote>
<p> 继承 JpaRepository：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AccountRepository extends JpaRepository&lt;Account,Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class AccountRepositoryTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testBaseQuery()&#123;</span><br><span class="line">        /*添加测试数据数据*/</span><br><span class="line">        accountRepository.deleteAll();</span><br><span class="line">        accountRepository.save(new Account(&quot;张三丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西太原&quot;,5000.5));</span><br><span class="line">        accountRepository.save(new Account(&quot;张四丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西临汾&quot;,1000));</span><br><span class="line">        </span><br><span class="line">        /*通过findAll方法查询所有记录*/</span><br><span class="line">        List&lt;Account&gt; accounts = accountRepository.findAll();</span><br><span class="line">        for(Account account : accounts)&#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /*通过findOne查询一条记录,传入ID*/</span><br><span class="line">        Account one = accountRepository.findOne(accountRepository.findAll().get(0).getId());</span><br><span class="line">        System.out.println(one.getUsername());</span><br><span class="line">        </span><br><span class="line">        /*查询总记录条数*/</span><br><span class="line">        long count = accountRepository.count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        </span><br><span class="line">        /*查询某条记录是否存在*/</span><br><span class="line">        boolean exists = accountRepository.exists(accountRepository.findAll().get(0).getId());</span><br><span class="line">        System.out.println(exists);</span><br><span class="line">        </span><br><span class="line">        /*更新记录,应该先查询到旧的记录在调用save方法，save方法的功能有两个：更新和添加*/</span><br><span class="line">        Account account = accountRepository.findAll().get(0);</span><br><span class="line">        account.setBalance(10000.4);</span><br><span class="line">        accountRepository.save(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-自定义简单查询"><a href="#2-自定义简单查询" class="headerlink" title="2.自定义简单查询"></a>2.自定义简单查询</h2><blockquote>
<p>自定义的简单查询就是根据方法名来自动生成 SQL，主要的语法是 findXXBy、readAXXBy、queryXXBy、countXXBy、getXXBy 后面跟属性名称：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User findByUsername(String userName);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以加一些关键字 And、Or：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User findByUsernameOrAddress(String username, String address);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改、删除、统计也是类似语法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Long deleteById(Long id);</span><br><span class="line">Long countByUsername(String userName)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基本上 SQL 体系中的关键词都可以使用，如 LIKE、IgnoreCase、OrderBy。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; findByAddressLike(String address);</span><br><span class="line">User findByAddressIgnoreCase(String address);</span><br><span class="line">List&lt;User&gt; findByAddressOrderByBalanceDesc(String address);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体的关键字，使用方法和生产成 SQL 如下表所示：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Keyword</th>
<th align="left">Sample</th>
<th>JPQL snippet</th>
</tr>
</thead>
<tbody><tr>
<td align="left">And</td>
<td align="left">findByLastnameAndFirstname</td>
<td>… where x.lastname = ?1 and x.firstname = ?2</td>
</tr>
<tr>
<td align="left">Or</td>
<td align="left">findByLastnameOrFirstname</td>
<td>… where x.lastname = ?1 or x.firstname = ?2</td>
</tr>
<tr>
<td align="left">Is,Equals</td>
<td align="left">findByFirstnameIs,findByFirstnameEquals</td>
<td>… where x.firstname = ?1</td>
</tr>
<tr>
<td align="left">Between</td>
<td align="left">findByStartDateBetween</td>
<td>… where x.startDate between ?1 and ?2</td>
</tr>
<tr>
<td align="left">LessThan</td>
<td align="left">findByAgeLessThan</td>
<td>… where x.age &lt; ?1</td>
</tr>
<tr>
<td align="left">LessThanEqual</td>
<td align="left">findByAgeLessThanEqual</td>
<td>… where x.age ⇐ ?1</td>
</tr>
<tr>
<td align="left">GreaterThan</td>
<td align="left">findByAgeGreaterThan</td>
<td>… where x.age &gt; ?1</td>
</tr>
<tr>
<td align="left">GreaterThanEqual</td>
<td align="left">findByAgeGreaterThanEqual</td>
<td>… where x.age &gt;= ?1</td>
</tr>
<tr>
<td align="left">After</td>
<td align="left">findByStartDateAfter</td>
<td>… where x.startDate &gt; ?1</td>
</tr>
<tr>
<td align="left">Before</td>
<td align="left">findByStartDateBefore</td>
<td>… where x.startDate &lt; ?1</td>
</tr>
<tr>
<td align="left">IsNull</td>
<td align="left">findByAgeIsNull</td>
<td>… where x.age is null</td>
</tr>
<tr>
<td align="left">IsNotNull,NotNull</td>
<td align="left">findByAge(Is)NotNull</td>
<td>… where x.age not null</td>
</tr>
<tr>
<td align="left">Like</td>
<td align="left">findByFirstnameLike</td>
<td>… where x.firstname like ?1</td>
</tr>
<tr>
<td align="left">NotLike</td>
<td align="left">findByFirstnameNotLike</td>
<td>… where x.firstname not like ?1</td>
</tr>
<tr>
<td align="left">StartingWith</td>
<td align="left">findByFirstnameStartingWith</td>
<td>… where x.firstname like ?1 (parameter bound with appended %)</td>
</tr>
<tr>
<td align="left">EndingWith</td>
<td align="left">findByFirstnameEndingWith</td>
<td>… where x.firstname like ?1 (parameter bound with prepended %)</td>
</tr>
<tr>
<td align="left">Containing</td>
<td align="left">findByFirstnameContaining</td>
<td>… where x.firstname like ?1 (parameter bound wrapped in %)</td>
</tr>
<tr>
<td align="left">OrderBy</td>
<td align="left">findByAgeOrderByLastnameDesc</td>
<td>… where x.age = ?1 order by x.lastname desc</td>
</tr>
<tr>
<td align="left">Not</td>
<td align="left">findByLastnameNot</td>
<td>… where x.lastname &lt;&gt; ?1</td>
</tr>
<tr>
<td align="left">In</td>
<td align="left">findByAgeIn(Collection<age> ages)</age></td>
<td>… where x.age in ?1</td>
</tr>
<tr>
<td align="left">NotIn</td>
<td align="left">findByAgeNotIn(Collection<age> age)</age></td>
<td>… where x.age not in ?1</td>
</tr>
<tr>
<td align="left">TRUE</td>
<td align="left">findByActiveTrue()</td>
<td>… where x.active = true</td>
</tr>
<tr>
<td align="left">FALSE</td>
<td align="left">findByActiveFalse()</td>
<td>… where x.active = false</td>
</tr>
<tr>
<td align="left">IgnoreCase</td>
<td align="left">findByFirstnameIgnoreCase</td>
<td>… where UPPER(x.firstame) = UPPER(?1)</td>
</tr>
</tbody></table>
<h2 id="3-分页查询"><a href="#3-分页查询" class="headerlink" title="3.分页查询"></a>3.分页查询</h2><blockquote>
<p>分页查询在实际使用中非常普遍了，Spring Data JPA 已经帮我们实现了分页的功能，在查询的方法中，需要传入参数 Pageable，当查询中有多个参数的时候 Pageable 建议做为最后一个参数传入：</p>
</blockquote>
<p> 在AccountRepository类中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageAccount findAllByAddressLike(String address, Pageable pageable);</span><br></pre></td></tr></table></figure>

<p> 测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void pageTest()&#123;</span><br><span class="line">    accountRepository.deleteAll();</span><br><span class="line">    accountRepository.save(new Account(&quot;张三丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西太原&quot;,5000.5));</span><br><span class="line">    accountRepository.save(new Account(&quot;张四丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西临汾&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;张五丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西忻州&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;张六丰&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;山西taiyuan&quot;,3000));</span><br><span class="line">    accountRepository.save(new Account(&quot;张七丰&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;山西linfen&quot;,9000.5));</span><br><span class="line">    accountRepository.save(new Account(&quot;张八丰&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;山西xinzhou&quot;,9000.5));</span><br><span class="line">    </span><br><span class="line">    int currentPage = 0;//第几页,从0开始</span><br><span class="line">    int size = 4;//每页多少条数据</span><br><span class="line">    Sort sort = new Sort(Sort.Direction.DESC, &quot;address&quot;);//按照address降序排序</span><br><span class="line">    Pageable pageable = new PageRequest(currentPage, size, sort);</span><br><span class="line">    </span><br><span class="line">    Page&lt;Account&gt; page = accountRepository.findAllByAddressLike(&quot;%西%&quot;,pageable);</span><br><span class="line">    System.out.println(&quot;一共有&quot;+page.getTotalPages()+&quot;页&quot;);</span><br><span class="line">    System.out.println(&quot;一共有&quot;+page.getTotalElements()+&quot;条记录&quot;);</span><br><span class="line">    System.out.println(&quot;本页的数据是有&quot;);</span><br><span class="line">    for(Account account : page)&#123;</span><br><span class="line">        System.out.println(account.getUsername()+&quot;\t&quot;+account.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一共有2页</span><br><span class="line">一共有6条记录</span><br><span class="line">本页的数据是有</span><br><span class="line">张五丰	山西忻州</span><br><span class="line">张三丰	山西太原</span><br><span class="line">张四丰	山西临汾</span><br><span class="line">张八丰	山西xinzhou</span><br></pre></td></tr></table></figure>

<h2 id="4-查询前N条数据"><a href="#4-查询前N条数据" class="headerlink" title="4.查询前N条数据"></a>4.查询前N条数据</h2><blockquote>
<p>有时候我们只需要查询前 N 个元素，或者只取前一个实体。可以在定义接口的时候使用firstBy,topBy,first4By,top4By</p>
</blockquote>
<p>1.在AccountRepository接口中添加新方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**查询前三个*/</span><br><span class="line">List&lt;Account&gt; findTop3ByOrderByBalanceDesc();</span><br><span class="line">/**查询余额最高的*/</span><br><span class="line">Account findFirstByOrderByBalanceDesc();</span><br><span class="line">/**查询余额最高的*/</span><br><span class="line">Account findTopByOrderByBalanceDesc();</span><br></pre></td></tr></table></figure>

<p>2.测试代码</p>
<pre><code>@Test
public void testTop(){
    accountRepository.deleteAll();
    accountRepository.save(new Account(&quot;张三丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西太原&quot;,5000.5));
    accountRepository.save(new Account(&quot;张四丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西临汾&quot;,1000));
    accountRepository.save(new Account(&quot;张五丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西忻州&quot;,1000));
    accountRepository.save(new Account(&quot;小明&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北承德&quot;,3000));
    accountRepository.save(new Account(&quot;小丽&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北保定&quot;,9000.5));

    //查询前3条记录
    List&lt;Account&gt; accounts = accountRepository.findTop3ByOrderByBalanceDesc();
    for (Account account: accounts) {
        System.out.println(account.getBalance());
    }

    /**查询余额最高的*/
    Account firstAccount = accountRepository.findFirstByOrderByBalanceDesc();
    System.out.println(firstAccount);

    /**查询余额最高的*/
    Account topAccount = accountRepository.findTopByOrderByBalanceDesc();
    System.out.println(topAccount);
}</code></pre><h2 id="5-自定义-SQL-查询"><a href="#5-自定义-SQL-查询" class="headerlink" title="5.自定义 SQL 查询"></a>5.自定义 SQL 查询</h2><blockquote>
<p>Spring Data JPA 也可以完美支持自定义SQL语句操作：</p>
<p>1.在 SQL 的查询方法上面使用 @Query 注解。</p>
<p>2.1如果需要传参可以在SQL中通过”:变量名”设置占位符，然后配合注解@Param(“变量名”)一起使用</p>
<p>2.2也可以使用？占位符，但是后面要跟1表示第一个参数如果多个问号只需要在每个?后面跟对应的数字就行了，从1开始</p>
<p>3.特别注意这里的 SQL 是 HQL，需要写类的名和属性，这块很容易出错。</p>
</blockquote>
<p>1.在AccountRepository接口中添加新方法(使用 “:变量名” 的方式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;select a from Account a where a.username = :name&quot;)</span><br><span class="line">Account selectByUsername(@Param(&quot;name&quot;) String username);</span><br><span class="line"></span><br><span class="line">@Query(&quot;select a from Account a where a.address like %:address%&quot;)</span><br><span class="line">ListAccount selectByAddressLike(@Param(&quot;address&quot;) String address);</span><br></pre></td></tr></table></figure>

<p>2.在AccountRepository接口中添加新方法(使用 “?” 的方式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;select a from Account a where a.address like ?1&quot;)</span><br><span class="line">ListAccount selectByAddressLike(String address);</span><br></pre></td></tr></table></figure>

<p>3.测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void userQuery()&#123;</span><br><span class="line">    //通过username查找对应的账户</span><br><span class="line">    Account zsf = accountRepository.selectByUsername(&quot;张三丰&quot;);</span><br><span class="line">    System.out.println(zsf.getUsername()+&quot;-&quot;+zsf.getGender());</span><br><span class="line"></span><br><span class="line">    //查找地址中包含&quot;西&quot;的账户</span><br><span class="line">    List&lt;Account&gt; accounts = accountRepository.selectByAddressLike(&quot;西&quot;);</span><br><span class="line">    for (Account account: accounts) &#123;</span><br><span class="line">    System.out.println(account.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-自定义SQL-更新或删除数据"><a href="#6-自定义SQL-更新或删除数据" class="headerlink" title="6.自定义SQL 更新或删除数据"></a>6.自定义SQL 更新或删除数据</h2><blockquote>
<p>提示：更新或者删除的时候需要添加@Modifying否则报 Not supported for DML operations 异常，也需要添加@Transactional事物注解，否则报InvalidDataAccessApiUsageException异常</p>
</blockquote>
<p>1.在AccountRepository接口中添加方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;update Account a set password = :password where username=:username&quot;)</span><br><span class="line">@Modifying</span><br><span class="line">@Transactional</span><br><span class="line">int updatePassswordByUsername(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);</span><br></pre></td></tr></table></figure>

<p>2.测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void userUpdateOrDelete()&#123;</span><br><span class="line">    accountRepository.deleteAll();</span><br><span class="line">    accountRepository.save(new Account(&quot;张三丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西太原&quot;,5000.5));</span><br><span class="line">    accountRepository.save(new Account(&quot;张四丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西临汾&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;张五丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西忻州&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;小明&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北承德&quot;,3000));</span><br><span class="line">    accountRepository.save(new Account(&quot;小丽&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北保定&quot;,9000.5));</span><br><span class="line"></span><br><span class="line">    int rows = accountRepository.updatePassswordByUsername(&quot;张三丰&quot;,&quot;88888888&quot;);</span><br><span class="line">    System.out.println(&quot;更新了&quot;+rows+&quot;行数据&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.控制台结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更新了1行数据</span><br></pre></td></tr></table></figure>

<h2 id="7-一对多关系-oneToMany"><a href="#7-一对多关系-oneToMany" class="headerlink" title="7.一对多关系(oneToMany)"></a>7.一对多关系(oneToMany)</h2><p>以班级和学生为例</p>
<p>​    班级和学生，一个个班级对应多个学生，班级就是一的一方，学生就是多的一方</p>
<p>需要在代表一的地方添加@OneToMany和@JoinColumn来标注(原理是在多的一方的表中增加一个外键列来保存关系)。代表多的实体不需要使用任何映射标注。</p>
<p>###班级类(Classes)</p>
<blockquote>
<p>班级代码 代表一的一方</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Classes &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line">    @Column(nullable = false,unique = true)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @OneToMany(cascade = CascadeType.ALL)</span><br><span class="line">    @JoinColumn(name = &quot;classes_id&quot;)//表示Student表中指向本表外键名</span><br><span class="line">    private List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###学生类(Student)</p>
<blockquote>
<p>学生代码 代表多的一方</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Student &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line">    @Column(nullable = false,unique = true)</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><blockquote>
<p> 测试代码：保存班级的同时保存学生ClassesRepository和StudentRepository此处省略..直接继承JpaRepository即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void saveTest()&#123;</span><br><span class="line">	/*创建班级*/</span><br><span class="line">    Classes bj = new Classes();</span><br><span class="line">    bj.setName(&quot;一年级二班&quot;);</span><br><span class="line">    /*创建学生*/</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setName(&quot;小明&quot;);</span><br><span class="line">    Student stu2 = new Student();</span><br><span class="line">    stu2.setName(&quot;小红&quot;);</span><br><span class="line">    </span><br><span class="line">	/*将学生添加到班级中*/</span><br><span class="line">    ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">    students.add(stu1);</span><br><span class="line">    students.add(stu2);</span><br><span class="line">    bj.setStudents(students);</span><br><span class="line">    </span><br><span class="line"> 	//保存班级,同时会级联保存学生</span><br><span class="line">    classesRepository.save(bj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成表的SQL</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: create table classes (id integer not null auto_increment, name varchar(255), primary key (id))</span><br><span class="line">Hibernate: create table student (id integer not null auto_increment, name varchar(255), class_id integer, primary key (id))</span><br><span class="line">Hibernate: alter table student add constraint FK5v50ed2bjh60n1gc7ifuxmgf4 foreign key (class_id) references classes (id)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>插入数据的SQL</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: insert into classes (name) values (?)</span><br><span class="line">Hibernate: insert into student (name) values (?)</span><br><span class="line">Hibernate: insert into student (name) values (?)</span><br><span class="line">Hibernate: update student set class_id=? where id=?</span><br><span class="line">Hibernate: update student set class_id=? where id=?</span><br></pre></td></tr></table></figure>

<h2 id="8-多对一关系-ManyToOne"><a href="#8-多对一关系-ManyToOne" class="headerlink" title="8.多对一关系(ManyToOne)"></a>8.多对一关系(ManyToOne)</h2><p>继续修改刚才的代码，在多的一方添加@ManyToOne</p>
<p>这里只需要在Student类中添加属性private Classes classes;生成get/set方法即可,并且在该属性上添加@ManyToOne(cascade={CascadeType.ALL})</p>
<blockquote>
<p>CascadeType.ALL表示级联删除，级联更新，级联新建，级联新建，比如删除主表，则从表也随之删除，详情见附录</p>
</blockquote>
<p>###学生类(Student)</p>
<blockquote>
<p>修改学生代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Student &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line">    @Column(nullable = false,unique = true)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(cascade=&#123;CascadeType.ALL&#125;)</span><br><span class="line">    private Classes classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###测试代码</p>
<blockquote>
<p>测试代码:查询所有学生对应的班级</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQuery()&#123;</span><br><span class="line">    List&lt;Student&gt; students = studentRepository.findAll();</span><br><span class="line">    for(Student student: students)&#123;</span><br><span class="line">        System.out.println(student.getClasses().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###可能遇到的异常</p>
<p>​    在controller返回数据到统一json转换的时候，出现了json infinite recursion stackoverflowerror的错误</p>
<p>​    具体的情况如下：</p>
<p>​    Classes类中，有个属性：private List<student> students;， Classes与Student的关系为 OneToMany；在Student类中，有属性private Classes classes;,引用到Classes中的字段id，并作为外键。hibernate查询结果正常，可以看到返回的Classes对象中，有Student参数值，但在json转换的时候就出现了无限递归的情况。原因是json在序列化Classes中的students属性的时候，找到了Student类，然后序列化Student类，而Student类中有classes属性，因此，为了序列化classes属性，json又得去序列化Classes类，如此递归反复，造成该问题。</student></p>
<p><strong>解决方法：</strong></p>
<p>​    在Student类中classes的setter方法上加注解@JsonBackReference</p>
<h2 id="9-多对多关系-ManyToMany"><a href="#9-多对多关系-ManyToMany" class="headerlink" title="9.多对多关系(ManyToMany)"></a>9.多对多关系(ManyToMany)</h2><p>以书和作者为例：</p>
<p>​    书(book)和作者(publisher)的可以看作多对多的关系，多对多关系需要一张中间表(book_publisher)来维护关系</p>
<p>关系图：</p>
<p><img src="//haoyongliang.gitee.io/2019/06/25/SpringBoot-master/03.SpringDataJPA使用/SpringDataJPA使用/many-to-many.png" alt="0"></p>
<p>###书类(Book)</p>
<blockquote>
<p>@JoinTable会生成第三张中间表,表名叫book_publisher,joinColumns表示当前实体(Book)的主键,inverseJoinColumns表示另一个实体(Publisher)的主键</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author:haoyongliang</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: created in 14:34 2018/5/22</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class Book&#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private int id;</span><br><span class="line">    @Column</span><br><span class="line">    private String name;</span><br><span class="line">    @ManyToMany(cascade = CascadeType.ALL)</span><br><span class="line">    @JoinTable(</span><br><span class="line">            name = &quot;book_publisher&quot;,</span><br><span class="line">            joinColumns = @JoinColumn(name = &quot;book_id&quot;,referencedColumnName = &quot;id&quot;),</span><br><span class="line">            inverseJoinColumns = @JoinColumn(name = &quot;publisher_id&quot;, referencedColumnName = &quot;id&quot;))</span><br><span class="line">    private Set&lt;Publisher&gt; publishers = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Book() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Book(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Book(String name, Set&lt;Publisher&gt; publishers)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.publishers = publishers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //TODO 省略GETTER/SETTER</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        String result = String.format(</span><br><span class="line">                &quot;Book [id=%d, name=&apos;%s&apos;]%n&quot;,</span><br><span class="line">                id, name);</span><br><span class="line">        if (publishers != null) &#123;</span><br><span class="line">            for(Publisher publisher : publishers) &#123;</span><br><span class="line">                result += String.format(</span><br><span class="line">                        &quot;Publisher[id=%d, name=&apos;%s&apos;]%n&quot;,</span><br><span class="line">                        publisher.getId(), publisher.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###作者类(Publisher)</p>
<blockquote>
<p>mappedBy = “publishers”表示关系由另一个实体(Book)维护，mappedBy 的值是Book类中的Set<book>属性的名字</book></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author:haoyongliang</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: created in 14:35 2018/5/22</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class Publisher &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private int id;</span><br><span class="line">    @Column</span><br><span class="line">    private String name;</span><br><span class="line">    @ManyToMany(mappedBy = &quot;publishers&quot;)</span><br><span class="line">    private Set&lt;Book&gt; books = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Publisher()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Publisher(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Publisher(String name, Set&lt;Book&gt; books)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.books = books;</span><br><span class="line">    &#125;</span><br><span class="line">	//TODO 省略GETTER/SETTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h3><blockquote>
<p>BookRepository和PublisherRepository直接继承JpaRepository即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author:haoyongliang</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: created in 15:08 2018/5/22</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@EntityScan(basePackages=&quot;cn.itcast.sprintBootDemo.domain&quot;)</span><br><span class="line">@EnableJpaRepositories(basePackages = &#123;&quot;cn.itcast.sprintBootDemo.repository&quot;&#125;)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class BookRepositoryTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookRepository bookRepository;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PublisherRepository publisherRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Transactional</span><br><span class="line">    public void findAll() throws Exception &#123;</span><br><span class="line">        Publisher luxun = new Publisher(&quot;鲁迅&quot;);</span><br><span class="line">        Publisher chenduxiu = new Publisher(&quot;陈独秀&quot;);</span><br><span class="line">        Publisher libai = new Publisher(&quot;李白&quot;);</span><br><span class="line"></span><br><span class="line">        Book book1 = new Book(&quot;SpringDataJpa&quot;);</span><br><span class="line">        book1.getPublishers().add(luxun);</span><br><span class="line"></span><br><span class="line">        Book book2 = new Book(&quot;基因传&quot;);</span><br><span class="line">        book2.getPublishers().add(chenduxiu);</span><br><span class="line">        book2.getPublishers().add(libai);</span><br><span class="line"></span><br><span class="line">        bookRepository.save(book1);</span><br><span class="line">        bookRepository.save(book2);</span><br><span class="line">        List&lt;Book&gt; books = bookRepository.findAll();</span><br><span class="line">        for (Iterator&lt;Book&gt; iterator = books.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">            Book book =  iterator.next();</span><br><span class="line">            System.out.println(book.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##10.一对一关系</p>
<p>以人和身份证为例,一个人(Person)对应一个(IDCard)，关系由人(Person)来维护</p>
<h3 id="人类-Person"><a href="#人类-Person" class="headerlink" title="人类(Person)"></a>人类(Person)</h3><p>因为关系由Person维护，所以这里使用@JoinColumn声明person表中外键的名字(外建名=另一个表的表名+”_”+另一个表的主键名)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import javax.persistence.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author:haoyongliang</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: created in 17:49 2018/5/22</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class Person &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private int id;</span><br><span class="line">    @Column</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    @OneToOne(cascade = CascadeType.ALL)</span><br><span class="line">    @JoinColumn(name = &quot;idCard_id&quot;)</span><br><span class="line">    private IDCard idCard;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //TODO 省略GETTER和SETTER</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###身份证类(IDCard)</p>
<blockquote>
<p>mappedBy = “idCard”表示关系由另一个实体(Person)维护，mappedBy 的值是Person类中的IDCard属性的名字</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import javax.persistence.*;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author:haoyongliang</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: created in 17:51 2018/5/22</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class IDCard &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private int id;</span><br><span class="line">    @Column(unique = true)</span><br><span class="line">    /**身份证号*/</span><br><span class="line">    private String no;</span><br><span class="line">    @Column</span><br><span class="line">    @Temporal(TemporalType.DATE)</span><br><span class="line">    /**有效期*/</span><br><span class="line">    private Date expiryDate;</span><br><span class="line">   </span><br><span class="line">    @OneToOne(mappedBy = &quot;idCard&quot;)</span><br><span class="line">    private Person person;</span><br><span class="line"></span><br><span class="line">    public IDCard() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IDCard(String no, Date expiryDate) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.expiryDate = expiryDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //TODO 省略GETTER和SETTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><blockquote>
<p>PersonRepository和IDCardRepository直接继承JpaRepository</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@EntityScan(basePackages=&quot;cn.itcast.sprintBootDemo.domain&quot;)</span><br><span class="line">@EnableJpaRepositories(basePackages = &#123;&quot;cn.itcast.sprintBootDemo.repository&quot;&#125;)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class PersonRepositoryTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    /**测试保存*/</span><br><span class="line">    public void add() throws Exception&#123;</span><br><span class="line">        IDCard idCard = new IDCard(&quot;14240xxxxxxxxxxx&quot;,new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;2030-09-09&quot;));</span><br><span class="line"></span><br><span class="line">        Person jack = new Person(&quot;Jack&quot;);</span><br><span class="line">        jack.setIdCard(idCard);</span><br><span class="line"></span><br><span class="line">        personRepository.save(jack);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    /**测试查询*/</span><br><span class="line">    public void query() &#123;</span><br><span class="line">        List&lt;Person&gt; all = personRepository.findAll();</span><br><span class="line">        for (Iterator&lt;Person&gt; iterator = all.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">            Person p =  iterator.next();</span><br><span class="line">            System.out.println(p.getIdCard().getNo());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote>
<p>为方便阅读,下面是本文涉及到的注解的相关说明,在阅读文章时对注解如有问题可以查阅此附录</p>
</blockquote>
<p>##@ManyToMany注解</p>
<p>BookRepository extends JpaRepository是属性或方法级别的注解，用于定义源实体与目标实体是多对多的关系。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>targetEntity</td>
<td>Class</td>
<td><strong>源实体</strong>关联的<strong>目标实体</strong>类型，默认是该成员属性对应的集合类型的泛型的参数化类型。</td>
</tr>
<tr>
<td>mappedBy</td>
<td>String</td>
<td>用在双向关联中。如果关系是双向的，则需定义此参数（与 @JoinColumn互斥，如果标注了 @JoinColumn注解，不需要再定义此参数）。</td>
</tr>
<tr>
<td>cascade</td>
<td>CascadeType[]</td>
<td>定义<strong>源实体</strong>和关联的<strong>目标实体</strong>间的级联关系。当对<strong>源实体</strong>进行操作时，是否对关联的<strong>目标实体</strong>也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项）</td>
</tr>
<tr>
<td>fetch</td>
<td>FetchType</td>
<td>定义关联的<strong>目标实体</strong>的数据的加载方式。可选值：FetchType.LAZY（延迟加载，默认）FetchType.EAGER（立即加载）延迟加载：只有在第一次访问<strong>源实体</strong>关联的<strong>目标实体</strong>的时候才去加载。立即加载：在加载<strong>源实体</strong>数据的时候同时去加载好关联的<strong>目标实体</strong>的数据。</td>
</tr>
</tbody></table>
<h2 id="OneToOne注解"><a href="#OneToOne注解" class="headerlink" title="@OneToOne注解"></a>@OneToOne注解</h2><p>是属性或方法级别的注解，用于定义源实体与目标实体是一对一的关系。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>targetEntity</td>
<td>Class</td>
<td><strong>源实体</strong>关联的<strong>目标实体</strong>类型，默认是该成员属性对应的类型，因此该参数通常可以缺省。</td>
</tr>
<tr>
<td>mappedBy</td>
<td>String</td>
<td>用在双向关联中。如果关系是双向的，只能有一方作为主体端，另一方则需声明此参数以表明将表间的这种关联关系转交给对方来维护。</td>
</tr>
<tr>
<td>cascade</td>
<td>CascadeType[]</td>
<td>定义<strong>源实体</strong>和关联的<strong>目标实体</strong>间的级联关系。当对<strong>源实体</strong>进行操作时，是否对关联的<strong>目标实体</strong>也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项）</td>
</tr>
<tr>
<td>fetch</td>
<td>FetchType</td>
<td>定义关联的<strong>目标实体</strong>的数据的加载方式。可选值：FetchType.LAZY（延迟加载）FetchType.EAGER（立即加载，默认）延迟加载：只有在第一次访问<strong>源实体</strong>关联的<strong>目标实体</strong>的时候才去加载。立即加载：在加载<strong>源实体</strong>数据的时候同时去加载好关联的<strong>目标实体</strong>的数据。</td>
</tr>
<tr>
<td>optional</td>
<td>boolean</td>
<td><strong>源实体</strong>关联的<strong>目标实体</strong>是否允许为 null，默认为 true。</td>
</tr>
<tr>
<td>orphanRemoval</td>
<td>boolean</td>
<td>当<strong>源实体</strong>关联的<strong>目标实体</strong>被断开（如给该属性赋予另外一个实例，或该属性的值被设为 null。被断开的实例称为孤值，因为已经找不到任何一个实例与之发生关联）时，是否自动删除断开的实例（在数据库中表现为删除表示该实例的行记录），默认为 false。</td>
</tr>
</tbody></table>
<h2 id="OneToMany注解"><a href="#OneToMany注解" class="headerlink" title="@OneToMany注解"></a>@OneToMany注解</h2><p>@OneToMany 是属性或方法级别的注解，用于定义源实体与目标实体是一对多的关系。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>targetEntity</td>
<td>Class</td>
<td><strong>源实体</strong>关联的<strong>目标实体</strong>类型，默认是该成员属性对应的集合类型的泛型的参数化类型。</td>
</tr>
<tr>
<td>mappedBy</td>
<td>String</td>
<td>用在双向关联中。如果关系是双向的，则需定义此参数（与 @JoinColumn 互斥，如果标注了 @JoinColumn注解，不需要再定义此参数）。</td>
</tr>
<tr>
<td>cascade</td>
<td>CascadeType[]</td>
<td>定义<strong>源实体</strong>和关联的<strong>目标实体</strong>间的级联关系。当对<strong>源实体</strong>进行操作时，是否对关联的<strong>目标实体</strong>也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项）</td>
</tr>
<tr>
<td>fetch</td>
<td>FetchType</td>
<td>定义关联的<strong>目标实体</strong>的数据的加载方式。可选值：FetchType.LAZY（延迟加载，默认）FetchType.EAGER（立即加载）延迟加载：只有在第一次访问<strong>源实体</strong>关联的<strong>目标实体</strong>的时候才去加载。立即加载：在加载<strong>源实体</strong>数据的时候同时去加载好关联的<strong>目标实体</strong>的数据。</td>
</tr>
<tr>
<td>orphanRemoval</td>
<td>boolean</td>
<td>当<strong>源实体</strong>关联的<strong>目标实体</strong>被断开（如给该属性赋予另外一个实例，或该属性的值被设为 null。被断开的实例称为孤值，因为已经找不到任何一个实例与之发生关联）时，是否自动删除断开的实例（在数据库中表现为删除表示该实例的行记录），默认为 false。(如果用CascadeType.REMOVE设置则必须要调用delete()方法才会删除)</td>
</tr>
</tbody></table>
<h2 id="ManyToOne注解"><a href="#ManyToOne注解" class="headerlink" title="@ManyToOne注解"></a>@ManyToOne注解</h2><p>@ManyToOne 是属性或方法级别的注解，用于定义源实体与目标实体是多对一的关系。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>targetEntity</td>
<td>Class</td>
<td><strong>源实体</strong>关联的<strong>目标实体</strong>类型，默认是该成员属性对应的类型，因此该参数通常可以缺省。</td>
</tr>
<tr>
<td>cascade</td>
<td>CascadeType[]</td>
<td>定义<strong>源实体</strong>和关联的<strong>目标实体</strong>间的级联关系。当对<strong>源实体</strong>进行操作时，是否对关联的<strong>目标实体</strong>也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项）</td>
</tr>
<tr>
<td>fetch</td>
<td>FetchType</td>
<td>定义关联的<strong>目标实体</strong>的数据的加载方式。可选值：FetchType.LAZY（延迟加载）FetchType.EAGER（立即加载，默认）延迟加载：只有在第一次访问<strong>源实体</strong>关联的<strong>目标实体</strong>的时候才去加载。立即加载：在加载<strong>源实体</strong>数据的时候同时去加载好关联的<strong>目标实体</strong>的数据。</td>
</tr>
<tr>
<td>optional</td>
<td>boolean</td>
<td><strong>源实体</strong>关联的<strong>目标实体</strong>是否允许为 null，默认为 true。</td>
</tr>
</tbody></table>
<h2 id="JoinTable注解"><a href="#JoinTable注解" class="headerlink" title="@JoinTable注解"></a>@JoinTable注解</h2><p>与 @Table 注解相类似，不同的是，@JoinTable 注解是用于定义关联表，它只能标注在实体类型的成员属性或方法上，常用于多对多或多对一的关联映射。如果没有声明，则使用该注解的默认值。</p>
<p>多对一时慎用，因为会生成第三张表</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>String</td>
<td>连接表的名称。</td>
</tr>
<tr>
<td>catalog</td>
<td>String</td>
<td>默认为数据库系统缺省的 catalog。</td>
</tr>
<tr>
<td>schema</td>
<td>String</td>
<td>默认为用户缺省的 schema。</td>
</tr>
<tr>
<td>joinColumns</td>
<td>JoinColumn[]</td>
<td>连接表中的外键列，通过使用 @JoinColumn 注解来声明，该外键参照<strong>源实体</strong>的主键。</td>
</tr>
<tr>
<td>inverseJoinColumns</td>
<td>JoinColumn[]</td>
<td>与 <code>joinColumns</code> 参数作用类似，只不过该外键参照的是<strong>目标实体</strong>的主键。</td>
</tr>
<tr>
<td>uniqueConstraints</td>
<td>UniqueConstraint[]</td>
<td>表的唯一约束（除了由 @Column 和 @JoinColumn注解指定的约束以及主键的约束之外的约束），通过使用 @UniqueConstraint注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的约束条件。</td>
</tr>
<tr>
<td>indexes</td>
<td>Index[]</td>
<td>表的索引，通过使用 @Index注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的索引。</td>
</tr>
<tr>
<td>foreignKey</td>
<td>ForeignKey</td>
<td>用于生成表时定义 <code>joinColumns</code> 参数的外键约束。</td>
</tr>
<tr>
<td>inverseForeignKey</td>
<td>ForeignKey</td>
<td>用于生成表时定义 <code>inverseJoinColumns</code> 参数的外键约束。</td>
</tr>
</tbody></table>
<p>##@JoinColumn注解</p>
<p>与 @Column 注解相类似，不同的是，@JoinColumn 注解是用于定义外键列，它只能标注在实体类型的成员属性或方法上，如果没有声明，则使用该注解的默认值。与 @Column 注解相类似，不同的是，@JoinColumn 注解是用于定义外键列，它只能标注在实体类型的成员属性或方法上，如果没有声明，则使用该注解的默认值。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>String</td>
<td>外键列的名称，默认为：<code>属性的名称</code> + <code>_</code> + <code>属性对应的实体的主键列的名称</code>（Hibernate 映射列时，若遇到驼峰拼写，会自动添加 <code>_</code> 连接并将大写字母改成小写）。</td>
</tr>
<tr>
<td>unique</td>
<td>boolean</td>
<td>外键列的值是否是唯一的。这是 @UniqueConstraint 注解的一个快捷方式，实质上是在声明唯一约束。默认值为 false。</td>
</tr>
<tr>
<td>nullable</td>
<td>boolean</td>
<td>外键列的值是否允许为 null。默认为 true。</td>
</tr>
<tr>
<td>insertable</td>
<td>boolean</td>
<td>外键列是否包含在 <code>INSERT</code> 语句中，默认为 true。</td>
</tr>
<tr>
<td>updatable</td>
<td>boolean</td>
<td>外键列是否包含在 <code>UPDATE</code> 语句中，默认为 true。</td>
</tr>
<tr>
<td>columnDefinition</td>
<td>String</td>
<td>生成外键列的 DDL 时使用的 SQL 片段。默认使用推断的类型来生成 SQL 片段以创建此列。</td>
</tr>
<tr>
<td>table</td>
<td>String</td>
<td>外键列所属的表的名称。默认值：如果是外键 <code>@OneToOne</code> 或 <code>@ManyToOne</code> 关联，则为<strong>源实体</strong>的表的名称；如果是单向外键 <code>@OneToMany</code> 关系，则为<strong>目标实体</strong>的表的名称；如果是 <code>@ManyToMany</code>、<code>@OneToOne</code>、双向 <code>@ManyToOne</code>、双向 <code>@OneToMany</code> 关联，则为连接表的名称；</td>
</tr>
</tbody></table>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">郝永亮</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://haoyongliang.gitee.io/2019/06/25/SpringBoot-master/03.SpringDataJPA使用/SpringDataJPA使用/">https://haoyongliang.gitee.io/2019/06/25/SpringBoot-master/03.SpringDataJPA使用/SpringDataJPA使用/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://haoyongliang.gitee.io">虫虫爬丫爬</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/07/05/dubble/ApacheDubbo/"><img class="prev_cover lozad" data-src="http://haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/3.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>分布式RPC框架Apache Dubbo</span></div></a></div><div class="next-post pull-right"><a href="/2019/06/25/SpringBoot-master/02.web开发实战/web开发实战/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span></span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2019 By 郝永亮</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://haoyongliang.gitee.io/">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/local-search.js"></script><script src="/js/nightshift.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>