<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/07/06/hexo-gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/07/06/hexo-gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<hr><p>title:hexo+gitee搭建个人博客<br>date:2019-07-06 21:33:30<br>tags:[博客搭建,gitee]</p><h2 id="top-img-hexo-gitee搭建个人博客-time-jpg"><a href="#top-img-hexo-gitee搭建个人博客-time-jpg" class="headerlink" title="top_img:(hexo-gitee搭建个人博客/time.jpg)"></a>top_img:(hexo-gitee搭建个人博客/time.jpg)</h2><p><a href="https://gitee.com/" target="_blank" rel="noopener">Gitee</a>: 由于github在国外，被墙了，于是把目光投向了国产Github，Gitee，算是支持国产吧。<br>Hexo：一个快速、简洁高效的博客框架，使用Markdown解析文本。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Windows用户访问<a href="https://nodejs.org/en" target="_blank" rel="noopener">Node.js</a>下载Node.js安装包后，直接运行安装即可(node.js下载也很慢，最好翻墙)。安装后，更换下npm的源，否则下载速度着实让人着急。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set registry http://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>Hexo的基本使用请查看hello-world文中所写。</p><h3 id="本地运行Hexo"><a href="#本地运行Hexo" class="headerlink" title="本地运行Hexo"></a>本地运行Hexo</h3><p>在本地选中一个空文件夹（一定要是空文件夹！！），在空文件中执行如下命令，生成Hexo运行所需要的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>初始化后，文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy       #需要部署的文件</span><br><span class="line">├── node_modules  #Hexo插件</span><br><span class="line">├── public        #生成的静态网页文件</span><br><span class="line">├── scaffolds     #模板</span><br><span class="line">├── source        #博客正文和其他源文件等都应该放在这里</span><br><span class="line">|   ├── _drafts   #草稿</span><br><span class="line">|   └── _posts    #文章</span><br><span class="line">├── themes        #主题</span><br><span class="line">├── _config.yml   #全局配置文件</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><p>之后在本地执行如下命令后，即可访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 访问Hexo页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git安装包地址</a>,根据操作系统选择安装包下载后安装即可。</p><h3 id="注册码云账号，并创建一个项目"><a href="#注册码云账号，并创建一个项目" class="headerlink" title="注册码云账号，并创建一个项目"></a>注册码云账号，并创建一个项目</h3><p><img src="//haoyongliang.gitee.io/2019/07/06/hexo-gitee搭建个人博客/01.png" alt></p><p><img src="//haoyongliang.gitee.io/2019/07/06/hexo-gitee搭建个人博客/02.png" alt></p><h3 id="获取项目地址"><a href="#获取项目地址" class="headerlink" title="获取项目地址"></a>获取项目地址</h3><p><img src="//haoyongliang.gitee.io/2019/07/06/hexo-gitee搭建个人博客/03.png" alt></p><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><h3 id="修改Hexo配置文件-config-yml"><a href="#修改Hexo配置文件-config-yml" class="headerlink" title="修改Hexo配置文件_config.yml"></a>修改Hexo配置文件_config.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: 码云的项目地址</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save </span><br><span class="line">$ hexo g --d  #一键部署</span><br></pre></td></tr></table></figure><p>此时会弹出一个对话框，提示输入码云的账号密码。部署成功后，登陆码云。此时本地文件夹中出现有一个public文件夹，代表部署成功。</p><h3 id="开启Page功能"><a href="#开启Page功能" class="headerlink" title="开启Page功能"></a>开启Page功能</h3><p><img src="//haoyongliang.gitee.io/2019/07/06/hexo-gitee搭建个人博客/04.png" alt></p><p><img src="//haoyongliang.gitee.io/2019/07/06/hexo-gitee搭建个人博客/05.png" alt></p><p><img src="//haoyongliang.gitee.io/2019/07/06/hexo-gitee搭建个人博客/06.png" alt></p><h3 id="访问博客"><a href="#访问博客" class="headerlink" title="访问博客"></a>访问博客</h3><p>在浏览器地址栏输入上图中的博客地址，即可访问，效果图如下：</p><p><img src="//haoyongliang.gitee.io/2019/07/06/hexo-gitee搭建个人博客/07.png" alt></p><h2 id="博客使用的主题"><a href="#博客使用的主题" class="headerlink" title="博客使用的主题"></a>博客使用的主题</h2><p><a href="https://jerryc.me/archives/" target="_blank" rel="noopener">https://jerryc.me/archives/</a></p><h2 id="博客内容编写"><a href="#博客内容编写" class="headerlink" title="博客内容编写"></a>博客内容编写</h2><p>在博客目录的source文件中的_post文件夹中添加你要写的博客文件，文件命名为<code>file_name.md</code><br><code>file_name.md</code>的文件开头如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: file_name</span><br><span class="line">tag: 标签名</span><br><span class="line">categories: 分类</span><br><span class="line">comment: 是否允许评论(true or false)</span><br><span class="line">description: 描述</span><br><span class="line">top_img: (設置頂部圖)</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式RPC框架Apache Dubbo</title>
      <link href="/2019/07/05/dubble/ApacheDubbo/"/>
      <url>/2019/07/05/dubble/ApacheDubbo/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式RPC框架Apache-Dubbo"><a href="#分布式RPC框架Apache-Dubbo" class="headerlink" title="分布式RPC框架Apache Dubbo"></a>分布式RPC框架Apache Dubbo</h1><h2 id="1-软件架构的演进过程"><a href="#1-软件架构的演进过程" class="headerlink" title="1. 软件架构的演进过程"></a>1. 软件架构的演进过程</h2><p>软件架构的发展经历了由单体架构、垂直架构、SOA架构到微服务架构的演进过程，下面我们分别了解一下这几个架构。</p><h3 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1 单体架构"></a>1.1 单体架构</h3><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/1.png" alt></p><p>架构说明：</p><p>​      全部功能集中在一个项目内（All in one）。</p><p>架构优点：</p><p>​      架构简单，前期开发成本低、开发周期短，适合小型项目。</p><p>架构缺点：</p><p>​       全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护。</p><p>​       技术栈受限，只能使用一种语言开发。</p><p>​       系统性能扩展只能通过扩展集群节点，成本高。</p><h3 id="1-2-垂直架构"><a href="#1-2-垂直架构" class="headerlink" title="1.2 垂直架构"></a>1.2 垂直架构</h3><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/18.png" alt="18"></p><p>架构说明：       </p><p>​      按照业务进行切割，形成小的单体项目。</p><p>架构优点：</p><p>​      技术栈可扩展（不同的系统可以用不同的编程语言编写）。</p><p>架构缺点：</p><p>​       功能集中在一个项目中，不利于开发、扩展、维护。</p><p>​       系统扩张只能通过集群的方式。</p><p>​       项目之间功能冗余、数据冗余、耦合性强。</p><h3 id="1-3-SOA架构"><a href="#1-3-SOA架构" class="headerlink" title="1.3 SOA架构"></a>1.3 SOA架构</h3><p>SOA全称为Service-Oriented Architecture，即面向服务的架构。它可以根据需求通过网络对松散耦合的粗粒度应用组件(服务)进行分布式部署、组合和使用。一个服务通常以独立的形式存在于操作系统进程中。</p><p>站在功能的角度，把业务逻辑抽象成可复用的服务，通过服务的编排实现业务的快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。</p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/19.png" alt="19"></p><p>架构说明：</p><p>​      将重复功能或模块抽取成组件的形式，对外提供服务，在项目与服务之间使用ESB（企业服务总线）的形式作为通信的桥梁。</p><p>架构优点：</p><p>​       重复功能或模块抽取为服务，提高开发效率。</p><p>​       可重用性高。</p><p>​       可维护性高。</p><p>架构缺点：</p><p>​       各系统之间业务不同，很难确认功能或模块是重复的。</p><p>​       抽取服务的粒度大。</p><p>​       系统和服务之间耦合度高。</p><h3 id="1-4-微服务架构"><a href="#1-4-微服务架构" class="headerlink" title="1.4 微服务架构"></a>1.4 微服务架构</h3><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/20.png" alt="20"></p><p>架构说明：</p><p>​       将系统服务层完全独立出来，抽取为一个一个的微服务。</p><p>​       抽取的粒度更细，遵循单一原则。</p><p>​       采用轻量级框架协议传输。</p><p>架构优点：</p><p>​       服务拆分粒度更细，有利于提高开发效率。 </p><p>​       可以针对不同服务制定对应的优化方案。</p><p>​       适用于互联网时代，产品迭代周期更短。</p><p>架构缺点：</p><p>​      粒度太细导致服务太多，维护成本高。</p><p>​      分布式系统开发的技术成本高，对团队的挑战大。</p><h2 id="2-Apache-Dubbo概述"><a href="#2-Apache-Dubbo概述" class="headerlink" title="2. Apache Dubbo概述"></a>2. Apache Dubbo概述</h2><h3 id="2-1-Dubbo简介"><a href="#2-1-Dubbo简介" class="headerlink" title="2.1 Dubbo简介"></a>2.1 Dubbo简介</h3><p>Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。</p><p><strong>什么是RPC？</strong></p><p>RPC全称为remote procedure call，即<strong>远程过程调用</strong>。比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。</p><p>需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。</p><p>RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo等。</p><p>Dubbo官网地址：<a href="http://dubbo.apache.org" target="_blank" rel="noopener">http://dubbo.apache.org</a></p><p>Dubbo提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><h3 id="2-2-Dubbo架构"><a href="#2-2-Dubbo架构" class="headerlink" title="2.2 Dubbo架构"></a>2.2 Dubbo架构</h3><p>Dubbo架构图（Dubbo官方提供）如下：</p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/2.png" alt="2"></p><p>节点角色说明：</p><table><thead><tr><th>节点</th><th>角色名称</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table><p>虚线都是异步访问，实线都是同步访问<br>蓝色虚线:在启动时完成的功能<br>红色虚线(实线)都是程序运行过程中执行的功能</p><p>调用关系说明:</p><ol start="0"><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h2 id="3-服务注册中心Zookeeper"><a href="#3-服务注册中心Zookeeper" class="headerlink" title="3. 服务注册中心Zookeeper"></a>3. 服务注册中心Zookeeper</h2><p>通过前面的Dubbo架构图可以看到，Registry（服务注册中心）在其中起着至关重要的作用。Dubbo官方推荐使用Zookeeper作为服务注册中心。</p><h3 id="3-1-Zookeeper介绍"><a href="#3-1-Zookeeper介绍" class="headerlink" title="3.1 Zookeeper介绍"></a>3.1 Zookeeper介绍</h3><p>Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 。</p><p>为了便于理解Zookeeper的树型目录服务，我们先来看一下我们电脑的文件系统(也是一个树型目录结构)：</p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/4.png" alt="4"></p><p>我的电脑可以分为多个盘符（例如C、D、E等），每个盘符下可以创建多个目录，每个目录下面可以创建文件，也可以创建子目录，最终构成了一个树型结构。通过这种树型结构的目录，我们可以将文件分门别类的进行存放，方便我们后期查找。而且磁盘上的每个文件都有一个唯一的访问路径，例如：C:\Windows\itcast\hello.txt。</p><p>Zookeeper树型目录服务：</p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/3.png" alt="3"></p><p>流程说明：</p><ul><li>服务提供者(Provider)启动时: 向 <code>/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址</li><li>服务消费者(Consumer)启动时: 订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址</li><li>监控中心(Monitor)启动时: 订阅 <code>/dubbo/com.foo.BarService</code> 目录下的所有提供者和消费者 URL 地址</li></ul><h3 id="3-2-安装Zookeeper"><a href="#3-2-安装Zookeeper" class="headerlink" title="3.2 安装Zookeeper"></a>3.2 安装Zookeeper</h3><p>下载地址：<a href="http://archive.apache.org/dist/zookeeper/" target="_blank" rel="noopener">http://archive.apache.org/dist/zookeeper/</a></p><p>本课程使用的Zookeeper版本为3.4.6，下载完成后可以获得名称为zookeeper-3.4.6.tar.gz的压缩文件。</p><p>安装步骤：</p><p>第一步：安装 jdk（略）<br>第二步：把 zookeeper 的压缩包（zookeeper-3.4.6.tar.gz）上传到 linux 系统<br>第三步：解压缩压缩包<br>​    tar -zxvf zookeeper-3.4.6.tar.gz<br>第四步：进入zookeeper-3.4.6目录，创建data目录<br>​    mkdir data<br>第五步：进入conf目录 ，把zoo_sample.cfg 改名为zoo.cfg<br>​    cd conf<br>​    mv zoo_sample.cfg zoo.cfg<br>第六步：打开zoo.cfg文件,  修改data属性：dataDir=/root/zookeeper-3.4.6/data</p><h3 id="3-3-启动、停止Zookeeper"><a href="#3-3-启动、停止Zookeeper" class="headerlink" title="3.3 启动、停止Zookeeper"></a>3.3 启动、停止Zookeeper</h3><p>进入Zookeeper的bin目录，启动服务命令<br> ./zkServer.sh start</p><p>启动报错使用命令查看错误信息： ./zkServer.sh start-foreground</p><p>停止服务命令<br>./zkServer.sh stop</p><p>查看服务状态：<br>./zkServer.sh status</p><h2 id="4-Dubbo快速入门"><a href="#4-Dubbo快速入门" class="headerlink" title="4. Dubbo快速入门"></a>4. Dubbo快速入门</h2><p>Dubbo作为一个RPC框架，其最核心的功能就是要实现跨网络的远程调用。本小节就是要创建两个应用，一个作为服务的提供方，一个作为服务的消费方。通过Dubbo来实现服务消费方远程调用服务提供方的方法。</p><h3 id="4-1-服务提供方开发"><a href="#4-1-服务提供方开发" class="headerlink" title="4.1 服务提供方开发"></a>4.1 服务提供方开发</h3><p>开发步骤：</p><p>（1）创建maven工程（打包方式为war）dubbodemo_provider，在pom.xml文件中导入如下坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- dubbo相关 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.sgroschupf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.1.GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定端口 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 请求路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）配置web.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE web-app PUBLIC</span></span><br><span class="line"><span class="meta"> "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"><span class="meta"> "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）创建服务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）创建服务实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service.impl;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：服务实现类上使用的Service注解是Dubbo提供的，用于对外发布服务</p><p>（5）在src/main/resources下创建applicationContext-service.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbodemo_provider"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://192.168.134.129:2181"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注册  协议和port   端口默认是20880 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20881"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.itheima.service.impl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（6）启动服务</p><p>tomcat7:run</p><h3 id="4-2-服务消费方开发"><a href="#4-2-服务消费方开发" class="headerlink" title="4.2 服务消费方开发"></a>4.2 服务消费方开发</h3><p>开发步骤：</p><p>（1）创建maven工程（打包方式为war）dubbodemo_consumer，pom.xml配置和上面服务提供者相同，只需要将Tomcat插件的端口号改为8082即可</p><p>（2）配置web.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE web-app PUBLIC</span></span><br><span class="line"><span class="meta"> "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"><span class="meta"> "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）将服务提供者工程中的HelloService接口复制到当前工程</p><p>（4）编写Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//远程调用</span></span><br><span class="line">        String result = helloService.sayHello(name);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Controller中注入HelloService使用的是Dubbo提供的@Reference注解</p><p>（5）在src/main/resources下创建applicationContext-web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbodemo-consumer"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://192.168.134.129:2181"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 扫描的方式暴露接口  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.itheima.controller"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（6）运行测试</p><p>tomcat7:run启动</p><p>在浏览器输入<a href="http://localhost:8082/demo/hello.do?name=Jack，查看浏览器输出结果" target="_blank" rel="noopener">http://localhost:8082/demo/hello.do?name=Jack，查看浏览器输出结果</a></p><p><strong>思考一：</strong>上面的Dubbo入门案例中我们是将HelloService接口从服务提供者工程(dubbodemo_provider)复制到服务消费者工程(dubbodemo_consumer)中，这种做法是否合适？还有没有更好的方式？</p><p><strong>答：</strong>这种做法显然是不好的，同一个接口被复制了两份，不利于后期维护。更好的方式是单独创建一个maven工程，将此接口创建在这个maven工程中。需要依赖此接口的工程只需要在自己工程的pom.xml文件中引入maven坐标即可。</p><p><strong>思考二：</strong>在服务消费者工程(dubbodemo_consumer)中只是引用了HelloService接口，并没有提供实现类，Dubbo是如何做到远程调用的？</p><p><strong>答：</strong>Dubbo底层是基于代理技术为HelloService接口创建代理对象，远程调用是通过此代理对象完成的。可以通过开发工具的debug功能查看此代理对象的内部结构。另外，Dubbo实现网络传输底层是基于Netty框架完成的。</p><p><strong>思考三：</strong>上面的Dubbo入门案例中我们使用Zookeeper作为服务注册中心，服务提供者需要将自己的服务信息注册到Zookeeper，服务消费者需要从Zookeeper订阅自己所需要的服务，此时Zookeeper服务就变得非常重要了，那如何防止Zookeeper单点故障呢？</p><p><strong>答：</strong>Zookeeper其实是支持集群模式的，可以配置Zookeeper集群来达到Zookeeper服务的高可用，防止出现单点故障。</p><h2 id="5-Dubbo管理控制台"><a href="#5-Dubbo管理控制台" class="headerlink" title="5. Dubbo管理控制台"></a>5. Dubbo管理控制台</h2><p>我们在开发时，需要知道Zookeeper注册中心都注册了哪些服务，有哪些消费者来消费这些服务。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。</p><h3 id="5-1-安装"><a href="#5-1-安装" class="headerlink" title="5.1 安装"></a>5.1 安装</h3><p>安装步骤：</p><p>（1）将资料中的dubbo-admin-2.6.0.war文件复制到tomcat的webapps目录下</p><p>（2）启动tomcat，此war文件会自动解压</p><p>（3）修改WEB-INF下的dubbo.properties文件，注意dubbo.registry.address对应的值需要对应当前使用的Zookeeper的ip地址和端口号</p><p>​    dubbo.registry.address=zookeeper://192.168.134.129:2181<br>​    dubbo.admin.root.password=root<br>​    dubbo.admin.guest.password=guest</p><p>（4）重启tomcat</p><h3 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h3><p>操作步骤：</p><p>（1）访问<a href="http://localhost:8080/dubbo-admin-2.6.0/，输入用户名(root)和密码(root)" target="_blank" rel="noopener">http://localhost:8080/dubbo-admin-2.6.0/，输入用户名(root)和密码(root)</a></p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/5.png" alt="5"></p><p>（2）启动服务提供者工程和服务消费者工程，可以在查看到对应的信息</p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/6.png" alt="6"></p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/7.png" alt="7"></p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/8.png" alt="8"></p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/9.png" alt="9"></p><h2 id="6-Dubbo相关配置说明"><a href="#6-Dubbo相关配置说明" class="headerlink" title="6. Dubbo相关配置说明"></a>6. Dubbo相关配置说明</h2><h3 id="6-1-包扫描"><a href="#6-1-包扫描" class="headerlink" title="6.1 包扫描"></a>6.1 包扫描</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.itheima.service"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>服务提供者和服务消费者都需要配置，表示包扫描，作用是扫描指定包(包括子包)下的类。</p><p>如果不使用包扫描，也可以通过如下配置的方式来发布服务：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.HelloServiceImpl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.itheima.api.HelloService"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>作为服务消费者，可以通过如下配置来引用服务：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用helloService --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">interface</span>=<span class="string">"com.itheima.api.HelloService"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上面这种方式发布和引用服务，一个配置项(<a href="dubbo:service" target="_blank" rel="noopener">dubbo:service</a>、<a href="dubbo:reference" target="_blank" rel="noopener">dubbo:reference</a>)只能发布或者引用一个服务，如果有多个服务，这种方式就比较繁琐了。推荐使用包扫描方式。</p><h3 id="6-2-协议"><a href="#6-2-协议" class="headerlink" title="6.2 协议"></a>6.2 协议</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>一般在服务提供者一方配置，可以指定使用的协议名称和端口号。</p><p>其中Dubbo支持的协议有：dubbo、rmi、hessian、http、webservice、rest、redis等。</p><p>推荐使用的是dubbo协议。</p><p>dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p><p>也可以在同一个工程中配置多个协议，不同服务可以使用不同的协议，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rmi"</span> <span class="attr">port</span>=<span class="string">"1099"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.itheima.api.HelloService"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span> <span class="attr">protocol</span>=<span class="string">"dubbo"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用rmi协议暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.itheima.api.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> <span class="attr">protocol</span>=<span class="string">"rmi"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-3-启动时检查"><a href="#6-3-启动时检查" class="headerlink" title="6.3 启动时检查"></a>6.3 启动时检查</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。</p><p>建议在开发阶段将check值设置为false，在生产环境下改为true。</p><h3 id="6-4-负载均衡"><a href="#6-4-负载均衡" class="headerlink" title="6.4 负载均衡"></a>6.4 负载均衡</h3><p>负载均衡（Load Balance）：其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。</p><p>在集群负载均衡时，Dubbo 提供了多种均衡策略（包括随机、轮询、最少活跃调用数、一致性Hash），缺省为random随机调用。</p><p>配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在服务消费者一方配置负载均衡策略</span></span><br><span class="line">    <span class="meta">@Reference</span>(check = <span class="keyword">false</span>,loadbalance = <span class="string">"random"</span>)</span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//远程调用</span></span><br><span class="line">        String result = helloService.sayHello(name);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在服务提供者一方配置负载均衡</span></span><br><span class="line"><span class="meta">@Service</span>(loadbalance = <span class="string">"random"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过启动多个服务提供者来观察Dubbo负载均衡效果。</p><p>注意：因为我们是在一台机器上启动多个服务提供者，所以需要修改tomcat的端口号和Dubbo服务的端口号来防止端口冲突。</p><p>在实际生产环境中，多个服务提供者是分别部署在不同的机器上，所以不存在端口冲突问题。</p><h2 id="7-解决Dubbo无法发布被事务代理的Service问题"><a href="#7-解决Dubbo无法发布被事务代理的Service问题" class="headerlink" title="7. 解决Dubbo无法发布被事务代理的Service问题"></a>7. 解决Dubbo无法发布被事务代理的Service问题</h2><p>前面我们已经完成了Dubbo的入门案例，通过入门案例我们可以看到通过Dubbo提供的标签配置就可以进行包扫描，扫描到@Service注解的类就可以被发布为服务。</p><p>但是我们如果在服务提供者类上加入@Transactional事务控制注解后，服务就发布不成功了。原因是事务控制的底层原理是为服务提供者类创建代理对象，而默认情况下Spring是基于JDK动态代理方式创建代理对象，而此代理对象的完整类名为com.sun.proxy.$Proxy42（最后两位数字不是固定的），导致Dubbo在发布服务前进行包匹配时无法完成匹配，进而没有进行服务的发布。</p><h3 id="7-1-问题展示"><a href="#7-1-问题展示" class="headerlink" title="7.1 问题展示"></a>7.1 问题展示</h3><p>在入门案例的服务提供者dubbodemo_provider工程基础上进行展示</p><p>操作步骤：</p><p>（1）在pom.xml文件中增加maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）在applicationContext-service.xml配置文件中加入数据源、事务管理器、开启事务注解的相关配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 事务管理器  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启事务控制的注解支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>上面连接的数据库可以自行创建</p><p>（3）在HelloServiceImpl类上加入@Transactional注解</p><p>（4）启动服务提供者和服务消费者，并访问</p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/12.png" alt="12"></p><p>上面的错误为没有可用的服务提供者</p><p>查看dubbo管理控制台发现服务并没有发布，如下：</p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/13.png" alt="13"></p><p>可以通过断点调试的方式查看Dubbo执行过程，Dubbo通过AnnotationBean的postProcessAfterInitialization方法进行处理</p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/14.png" alt="14"></p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/15.png" alt="15"></p><h3 id="7-2-解决方案"><a href="#7-2-解决方案" class="headerlink" title="7.2 解决方案"></a>7.2 解决方案</h3><p>通过上面的断点调试可以看到，在HelloServiceImpl类上加入事务注解后，Spring会为此类基于JDK动态代理技术创建代理对象，创建的代理对象完整类名为com.sun.proxy.$Proxy35，导致Dubbo在进行包匹配时没有成功（因为我们在发布服务时扫描的包为com.itheima.service），所以后面真正发布服务的代码没有执行。</p><p>解决方式操作步骤：</p><p>（1）修改applicationContext-service.xml配置文件，开启事务控制注解支持时指定proxy-target-class属性，值为true。其作用是使用cglib代理方式为Service类创建代理对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启事务控制的注解支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/17.png" alt="17"></p><p>（2）修改HelloServiceImpl类，在Service注解中加入interfaceClass属性，值为HelloService.class，作用是指定服务的接口类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(interfaceClass = HelloService.class)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处也是必须要修改的，否则会导致发布的服务接口为SpringProxy，而不是HelloService接口，如下：</p><p><img src="//haoyongliang.gitee.io/2019/07/05/dubble/ApacheDubbo/16.png" alt="16"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubble </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/25/SpringBoot-master/03.SpringDataJPA%E4%BD%BF%E7%94%A8/SpringDataJPA%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/25/SpringBoot-master/03.SpringDataJPA%E4%BD%BF%E7%94%A8/SpringDataJPA%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot技术栈-Spring-Data-JPA"><a href="#Spring-Boot技术栈-Spring-Data-JPA" class="headerlink" title="Spring Boot技术栈(Spring Data JPA)"></a>Spring Boot技术栈(Spring Data JPA)</h1><blockquote><p>本篇介绍 通过Spring Data JPA对数据库进行常见的操作:删除、修改、添加、条件查询、分页查询、单表查询、多表查询。</p></blockquote><h1 id="1-Spring-Data-JPA介绍"><a href="#1-Spring-Data-JPA介绍" class="headerlink" title="1.Spring Data JPA介绍"></a>1.Spring Data JPA介绍</h1><ul><li>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！</li><li>Spring Data JPA 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现。</li></ul><h1 id="2-开发环境搭建"><a href="#2-开发环境搭建" class="headerlink" title="2.开发环境搭建"></a>2.开发环境搭建</h1><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.Springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-修改application-properties"><a href="#2-修改application-properties" class="headerlink" title="2.修改application.properties"></a>2.修改application.properties</h2><p>添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#数据库连接URL</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/heima</span><br><span class="line">#数据库帐号</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">#数据库密码</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">#驱动名 </span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">#每次hibernate 时根据 model 类自动更新表结构</span><br><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br><span class="line">#告诉Hibernate，将HQL翻译成哪种数据库的SQL</span><br><span class="line">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">#是否在控制台打印SQL语句,测试时设置为true</span><br><span class="line">spring.jpa.show-sql= true</span><br></pre></td></tr></table></figure><p>配置文件说明</p><blockquote><ol><li>spring.jpa.properties.hibernate.hbm2ddl.auto : 自动创建 | 更新 | 验证数据库表结构<ul><li>create : 每次加载hibernate，如果数据库中存在表，将所有表删除，然后重新生成表</li><li>update 每次hibernate 时根据 model 类自动更新表结构，如果是第一次则创建表结构。之前表数据不会删除</li><li>validate : 设置为validate:加载hibernate时，验证创建数据库表结构，这样 spring在加载之初，如果model层和数据库表结构不同，就会报错，这样有助于技术运维预先发现问题。例如：ProductInfoEntity这个实体有property1这个属性，而对应的数据库表product没有property1这个字段，就会在tomcat启动的时候报错：错误可能如下：Missing column: property1 in wjs.product</li><li>create-drop : 如果一开始数据库没有表，启动tomcat的时候会生成表，当把tomcat关闭之后生成的表又会消除</li></ul></li><li>spring.jpa.properties.hibernate.dialect ： 告诉Hibernate，将HQL翻译成哪种数据库的SQL,常见的有<ul><li>mysql : org.hibernate.dialect.MySQLDialect</li><li>oracle : org.hibernate.dialect.OracleDialect</li><li>sqlserver : org.hibernate.dialect.SQLServerDialect</li></ul></li></ol></blockquote><h2 id="3-创建实体类"><a href="#3-创建实体类" class="headerlink" title="3.创建实体类"></a>3.创建实体类</h2><ul><li>注意：<ul><li>实体类在命名时候不要用数据库中的关键字比如Order,可以定义成Orders<ul><li>Entity 中不映射成列的字段得加 @Transient 注解，不加注解也会映射成列</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">账户</span><br><span class="line">*/</span><br><span class="line">@Entity</span><br><span class="line">public class Account implements Serializable&#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;//ID主键</span><br><span class="line">    @Column(nullable = false,unique = true)</span><br><span class="line">    private String username;//用户名,不能为空，不能重复</span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private String password;//密码，不能为空</span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private String gender;  //性别，不能为空</span><br><span class="line">    @Column()</span><br><span class="line">    private String address; //地址</span><br><span class="line">    @Column()</span><br><span class="line">    private double balance;//账户余额</span><br><span class="line">    </span><br><span class="line">    public Account(String username, String password, String gender, String address, double balance) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">        this.address = address;</span><br><span class="line">        this.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    //省略无参构造,getter,setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-创建DAO"><a href="#4-创建DAO" class="headerlink" title="4.创建DAO"></a>4.创建DAO</h2><p> Dao 只要继承 JpaRepository 类就可以，几乎可以不用写方法，还有一个特别有个性的功能非常赞，就是可以根据方法名来自动的生产 SQL，如 findByUserName 会自动生产一个以 userName 为参数的查询方法，如 findAll 自动会查询表里面的所有数据，如自动分页等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface AccountRepository extends JpaRepositoryAccount,Long &#123;</span><br><span class="line">    Account findAccountByUsername(String username);</span><br><span class="line">    List&lt;Account&gt; findAllByAddressLike(String address);//比如查询地址包含&quot;西&quot;的 address的值=&quot;%西%&quot;</span><br><span class="line">    List&lt;Account&gt; findAllByBalanceGreaterThanEqual(double balance);//余额大于等于指定金额</span><br><span class="line">    List&lt;Account&gt; findAllByBalanceGreaterThan(double balance);//余额大于指定金额</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说明：JpaRepository&lt;T,ID&gt;这个接口只是一个空的接口，目的是为了统一所有Repository的类型，其接口类型使用了泛型，泛型参数中T代表实体类型，ID则是实体中id的类型</li></ul><h2 id="5-编写测试代码"><a href="#5-编写测试代码" class="headerlink" title="5.编写测试代码"></a>5.编写测试代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class AccountRepositoryTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountRepository accountRepository;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()  &#123;</span><br><span class="line">    accountRepository.deleteAll();</span><br><span class="line">    accountRepository.save(new Account(&quot;张三丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西太原&quot;,5000.5));</span><br><span class="line">    accountRepository.save(new Account(&quot;张四丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西临汾&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;张五丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西忻州&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;小明&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北承德&quot;,3000));</span><br><span class="line">    accountRepository.save(new Account(&quot;小丽&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北保定&quot;,9000.5));</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(5,accountRepository.findAll().size());//如果查询结果等于5</span><br><span class="line">    Assert.assertEquals(3,accountRepository.findAllByAddressLike(&quot;%西%&quot;).size());//地址中包含西的记录</span><br><span class="line">    Assert.assertEquals(3,accountRepository.findAllByBalanceGreaterThanEqual(3000).size());//大于等于3000的余额的记录</span><br><span class="line">    Assert.assertEquals(2,accountRepository.findAllByBalanceGreaterThan(3000).size());//大于3000的余额的记录</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##6.运行时报错及解决方案</p><p>可能出现异常：</p><ol><li>Caused by: java.lang.IllegalArgumentException: Not a managed type: class com.nsun.study.dao.model.UserInfo<br>at org.hibernate.jpa.internal.metamodel.MetamodelImpl.managedType(MetamodelImpl.java:210)</li><li>Consider defining a bean of type ‘*Repository’ in your configuration. </li></ol><p>原因：启动时没有扫描实体类和DAO,导致没有注入</p><p>解决方案：在Application 增加注解(测试类也添加)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EntityScan(basePackages=&quot;cn.itcast.sprintBootDemo.domain&quot;)</span><br><span class="line">@EnableJpaRepositories(basePackages = &#123;&quot;cn.itcast.sprintBootDemo.repository&quot;&#125;)</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class SprintBootDemoApplication &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SprintBootDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-常见数据库操作"><a href="#3-常见数据库操作" class="headerlink" title="3.常见数据库操作"></a>3.常见数据库操作</h1><blockquote><p>基本查询也分为两种，一种是 Spring Data 默认已经实现，一种是根据查询的方法来自动解析成 SQL。</p></blockquote><h2 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="1.基本查询"></a>1.基本查询</h2><blockquote><p>Spring Data JPA 默认预先生成了一些基本的 CURD 的方法，如增加，删除，修改，查询</p></blockquote><p> 继承 JpaRepository：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AccountRepository extends JpaRepository&lt;Account,Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class AccountRepositoryTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testBaseQuery()&#123;</span><br><span class="line">        /*添加测试数据数据*/</span><br><span class="line">        accountRepository.deleteAll();</span><br><span class="line">        accountRepository.save(new Account(&quot;张三丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西太原&quot;,5000.5));</span><br><span class="line">        accountRepository.save(new Account(&quot;张四丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西临汾&quot;,1000));</span><br><span class="line">        </span><br><span class="line">        /*通过findAll方法查询所有记录*/</span><br><span class="line">        List&lt;Account&gt; accounts = accountRepository.findAll();</span><br><span class="line">        for(Account account : accounts)&#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /*通过findOne查询一条记录,传入ID*/</span><br><span class="line">        Account one = accountRepository.findOne(accountRepository.findAll().get(0).getId());</span><br><span class="line">        System.out.println(one.getUsername());</span><br><span class="line">        </span><br><span class="line">        /*查询总记录条数*/</span><br><span class="line">        long count = accountRepository.count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        </span><br><span class="line">        /*查询某条记录是否存在*/</span><br><span class="line">        boolean exists = accountRepository.exists(accountRepository.findAll().get(0).getId());</span><br><span class="line">        System.out.println(exists);</span><br><span class="line">        </span><br><span class="line">        /*更新记录,应该先查询到旧的记录在调用save方法，save方法的功能有两个：更新和添加*/</span><br><span class="line">        Account account = accountRepository.findAll().get(0);</span><br><span class="line">        account.setBalance(10000.4);</span><br><span class="line">        accountRepository.save(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-自定义简单查询"><a href="#2-自定义简单查询" class="headerlink" title="2.自定义简单查询"></a>2.自定义简单查询</h2><blockquote><p>自定义的简单查询就是根据方法名来自动生成 SQL，主要的语法是 findXXBy、readAXXBy、queryXXBy、countXXBy、getXXBy 后面跟属性名称：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User findByUsername(String userName);</span><br></pre></td></tr></table></figure><blockquote><p>也可以加一些关键字 And、Or：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User findByUsernameOrAddress(String username, String address);</span><br></pre></td></tr></table></figure><blockquote><p>修改、删除、统计也是类似语法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Long deleteById(Long id);</span><br><span class="line">Long countByUsername(String userName)</span><br></pre></td></tr></table></figure><blockquote><p>基本上 SQL 体系中的关键词都可以使用，如 LIKE、IgnoreCase、OrderBy。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; findByAddressLike(String address);</span><br><span class="line">User findByAddressIgnoreCase(String address);</span><br><span class="line">List&lt;User&gt; findByAddressOrderByBalanceDesc(String address);</span><br></pre></td></tr></table></figure><blockquote><p>具体的关键字，使用方法和生产成 SQL 如下表所示：</p></blockquote><table><thead><tr><th align="left">Keyword</th><th align="left">Sample</th><th>JPQL snippet</th></tr></thead><tbody><tr><td align="left">And</td><td align="left">findByLastnameAndFirstname</td><td>… where x.lastname = ?1 and x.firstname = ?2</td></tr><tr><td align="left">Or</td><td align="left">findByLastnameOrFirstname</td><td>… where x.lastname = ?1 or x.firstname = ?2</td></tr><tr><td align="left">Is,Equals</td><td align="left">findByFirstnameIs,findByFirstnameEquals</td><td>… where x.firstname = ?1</td></tr><tr><td align="left">Between</td><td align="left">findByStartDateBetween</td><td>… where x.startDate between ?1 and ?2</td></tr><tr><td align="left">LessThan</td><td align="left">findByAgeLessThan</td><td>… where x.age &lt; ?1</td></tr><tr><td align="left">LessThanEqual</td><td align="left">findByAgeLessThanEqual</td><td>… where x.age ⇐ ?1</td></tr><tr><td align="left">GreaterThan</td><td align="left">findByAgeGreaterThan</td><td>… where x.age &gt; ?1</td></tr><tr><td align="left">GreaterThanEqual</td><td align="left">findByAgeGreaterThanEqual</td><td>… where x.age &gt;= ?1</td></tr><tr><td align="left">After</td><td align="left">findByStartDateAfter</td><td>… where x.startDate &gt; ?1</td></tr><tr><td align="left">Before</td><td align="left">findByStartDateBefore</td><td>… where x.startDate &lt; ?1</td></tr><tr><td align="left">IsNull</td><td align="left">findByAgeIsNull</td><td>… where x.age is null</td></tr><tr><td align="left">IsNotNull,NotNull</td><td align="left">findByAge(Is)NotNull</td><td>… where x.age not null</td></tr><tr><td align="left">Like</td><td align="left">findByFirstnameLike</td><td>… where x.firstname like ?1</td></tr><tr><td align="left">NotLike</td><td align="left">findByFirstnameNotLike</td><td>… where x.firstname not like ?1</td></tr><tr><td align="left">StartingWith</td><td align="left">findByFirstnameStartingWith</td><td>… where x.firstname like ?1 (parameter bound with appended %)</td></tr><tr><td align="left">EndingWith</td><td align="left">findByFirstnameEndingWith</td><td>… where x.firstname like ?1 (parameter bound with prepended %)</td></tr><tr><td align="left">Containing</td><td align="left">findByFirstnameContaining</td><td>… where x.firstname like ?1 (parameter bound wrapped in %)</td></tr><tr><td align="left">OrderBy</td><td align="left">findByAgeOrderByLastnameDesc</td><td>… where x.age = ?1 order by x.lastname desc</td></tr><tr><td align="left">Not</td><td align="left">findByLastnameNot</td><td>… where x.lastname &lt;&gt; ?1</td></tr><tr><td align="left">In</td><td align="left">findByAgeIn(Collection<age> ages)</age></td><td>… where x.age in ?1</td></tr><tr><td align="left">NotIn</td><td align="left">findByAgeNotIn(Collection<age> age)</age></td><td>… where x.age not in ?1</td></tr><tr><td align="left">TRUE</td><td align="left">findByActiveTrue()</td><td>… where x.active = true</td></tr><tr><td align="left">FALSE</td><td align="left">findByActiveFalse()</td><td>… where x.active = false</td></tr><tr><td align="left">IgnoreCase</td><td align="left">findByFirstnameIgnoreCase</td><td>… where UPPER(x.firstame) = UPPER(?1)</td></tr></tbody></table><h2 id="3-分页查询"><a href="#3-分页查询" class="headerlink" title="3.分页查询"></a>3.分页查询</h2><blockquote><p>分页查询在实际使用中非常普遍了，Spring Data JPA 已经帮我们实现了分页的功能，在查询的方法中，需要传入参数 Pageable，当查询中有多个参数的时候 Pageable 建议做为最后一个参数传入：</p></blockquote><p> 在AccountRepository类中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageAccount findAllByAddressLike(String address, Pageable pageable);</span><br></pre></td></tr></table></figure><p> 测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void pageTest()&#123;</span><br><span class="line">    accountRepository.deleteAll();</span><br><span class="line">    accountRepository.save(new Account(&quot;张三丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西太原&quot;,5000.5));</span><br><span class="line">    accountRepository.save(new Account(&quot;张四丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西临汾&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;张五丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西忻州&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;张六丰&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;山西taiyuan&quot;,3000));</span><br><span class="line">    accountRepository.save(new Account(&quot;张七丰&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;山西linfen&quot;,9000.5));</span><br><span class="line">    accountRepository.save(new Account(&quot;张八丰&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;山西xinzhou&quot;,9000.5));</span><br><span class="line">    </span><br><span class="line">    int currentPage = 0;//第几页,从0开始</span><br><span class="line">    int size = 4;//每页多少条数据</span><br><span class="line">    Sort sort = new Sort(Sort.Direction.DESC, &quot;address&quot;);//按照address降序排序</span><br><span class="line">    Pageable pageable = new PageRequest(currentPage, size, sort);</span><br><span class="line">    </span><br><span class="line">    Page&lt;Account&gt; page = accountRepository.findAllByAddressLike(&quot;%西%&quot;,pageable);</span><br><span class="line">    System.out.println(&quot;一共有&quot;+page.getTotalPages()+&quot;页&quot;);</span><br><span class="line">    System.out.println(&quot;一共有&quot;+page.getTotalElements()+&quot;条记录&quot;);</span><br><span class="line">    System.out.println(&quot;本页的数据是有&quot;);</span><br><span class="line">    for(Account account : page)&#123;</span><br><span class="line">        System.out.println(account.getUsername()+&quot;\t&quot;+account.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一共有2页</span><br><span class="line">一共有6条记录</span><br><span class="line">本页的数据是有</span><br><span class="line">张五丰山西忻州</span><br><span class="line">张三丰山西太原</span><br><span class="line">张四丰山西临汾</span><br><span class="line">张八丰山西xinzhou</span><br></pre></td></tr></table></figure><h2 id="4-查询前N条数据"><a href="#4-查询前N条数据" class="headerlink" title="4.查询前N条数据"></a>4.查询前N条数据</h2><blockquote><p>有时候我们只需要查询前 N 个元素，或者只取前一个实体。可以在定义接口的时候使用firstBy,topBy,first4By,top4By</p></blockquote><p>1.在AccountRepository接口中添加新方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**查询前三个*/</span><br><span class="line">List&lt;Account&gt; findTop3ByOrderByBalanceDesc();</span><br><span class="line">/**查询余额最高的*/</span><br><span class="line">Account findFirstByOrderByBalanceDesc();</span><br><span class="line">/**查询余额最高的*/</span><br><span class="line">Account findTopByOrderByBalanceDesc();</span><br></pre></td></tr></table></figure><p>2.测试代码</p><pre><code>@Testpublic void testTop(){    accountRepository.deleteAll();    accountRepository.save(new Account(&quot;张三丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西太原&quot;,5000.5));    accountRepository.save(new Account(&quot;张四丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西临汾&quot;,1000));    accountRepository.save(new Account(&quot;张五丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西忻州&quot;,1000));    accountRepository.save(new Account(&quot;小明&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北承德&quot;,3000));    accountRepository.save(new Account(&quot;小丽&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北保定&quot;,9000.5));    //查询前3条记录    List&lt;Account&gt; accounts = accountRepository.findTop3ByOrderByBalanceDesc();    for (Account account: accounts) {        System.out.println(account.getBalance());    }    /**查询余额最高的*/    Account firstAccount = accountRepository.findFirstByOrderByBalanceDesc();    System.out.println(firstAccount);    /**查询余额最高的*/    Account topAccount = accountRepository.findTopByOrderByBalanceDesc();    System.out.println(topAccount);}</code></pre><h2 id="5-自定义-SQL-查询"><a href="#5-自定义-SQL-查询" class="headerlink" title="5.自定义 SQL 查询"></a>5.自定义 SQL 查询</h2><blockquote><p>Spring Data JPA 也可以完美支持自定义SQL语句操作：</p><p>1.在 SQL 的查询方法上面使用 @Query 注解。</p><p>2.1如果需要传参可以在SQL中通过”:变量名”设置占位符，然后配合注解@Param(“变量名”)一起使用</p><p>2.2也可以使用？占位符，但是后面要跟1表示第一个参数如果多个问号只需要在每个?后面跟对应的数字就行了，从1开始</p><p>3.特别注意这里的 SQL 是 HQL，需要写类的名和属性，这块很容易出错。</p></blockquote><p>1.在AccountRepository接口中添加新方法(使用 “:变量名” 的方式)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;select a from Account a where a.username = :name&quot;)</span><br><span class="line">Account selectByUsername(@Param(&quot;name&quot;) String username);</span><br><span class="line"></span><br><span class="line">@Query(&quot;select a from Account a where a.address like %:address%&quot;)</span><br><span class="line">ListAccount selectByAddressLike(@Param(&quot;address&quot;) String address);</span><br></pre></td></tr></table></figure><p>2.在AccountRepository接口中添加新方法(使用 “?” 的方式)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;select a from Account a where a.address like ?1&quot;)</span><br><span class="line">ListAccount selectByAddressLike(String address);</span><br></pre></td></tr></table></figure><p>3.测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void userQuery()&#123;</span><br><span class="line">    //通过username查找对应的账户</span><br><span class="line">    Account zsf = accountRepository.selectByUsername(&quot;张三丰&quot;);</span><br><span class="line">    System.out.println(zsf.getUsername()+&quot;-&quot;+zsf.getGender());</span><br><span class="line"></span><br><span class="line">    //查找地址中包含&quot;西&quot;的账户</span><br><span class="line">    List&lt;Account&gt; accounts = accountRepository.selectByAddressLike(&quot;西&quot;);</span><br><span class="line">    for (Account account: accounts) &#123;</span><br><span class="line">    System.out.println(account.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-自定义SQL-更新或删除数据"><a href="#6-自定义SQL-更新或删除数据" class="headerlink" title="6.自定义SQL 更新或删除数据"></a>6.自定义SQL 更新或删除数据</h2><blockquote><p>提示：更新或者删除的时候需要添加@Modifying否则报 Not supported for DML operations 异常，也需要添加@Transactional事物注解，否则报InvalidDataAccessApiUsageException异常</p></blockquote><p>1.在AccountRepository接口中添加方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;update Account a set password = :password where username=:username&quot;)</span><br><span class="line">@Modifying</span><br><span class="line">@Transactional</span><br><span class="line">int updatePassswordByUsername(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);</span><br></pre></td></tr></table></figure><p>2.测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void userUpdateOrDelete()&#123;</span><br><span class="line">    accountRepository.deleteAll();</span><br><span class="line">    accountRepository.save(new Account(&quot;张三丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西太原&quot;,5000.5));</span><br><span class="line">    accountRepository.save(new Account(&quot;张四丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西临汾&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;张五丰&quot;,&quot;123456&quot;,&quot;男&quot;,&quot;山西忻州&quot;,1000));</span><br><span class="line">    accountRepository.save(new Account(&quot;小明&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北承德&quot;,3000));</span><br><span class="line">    accountRepository.save(new Account(&quot;小丽&quot;,&quot;123456&quot;,&quot;女&quot;,&quot;河北保定&quot;,9000.5));</span><br><span class="line"></span><br><span class="line">    int rows = accountRepository.updatePassswordByUsername(&quot;张三丰&quot;,&quot;88888888&quot;);</span><br><span class="line">    System.out.println(&quot;更新了&quot;+rows+&quot;行数据&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.控制台结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更新了1行数据</span><br></pre></td></tr></table></figure><h2 id="7-一对多关系-oneToMany"><a href="#7-一对多关系-oneToMany" class="headerlink" title="7.一对多关系(oneToMany)"></a>7.一对多关系(oneToMany)</h2><p>以班级和学生为例</p><p>​    班级和学生，一个个班级对应多个学生，班级就是一的一方，学生就是多的一方</p><p>需要在代表一的地方添加@OneToMany和@JoinColumn来标注(原理是在多的一方的表中增加一个外键列来保存关系)。代表多的实体不需要使用任何映射标注。</p><p>###班级类(Classes)</p><blockquote><p>班级代码 代表一的一方</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Classes &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line">    @Column(nullable = false,unique = true)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @OneToMany(cascade = CascadeType.ALL)</span><br><span class="line">    @JoinColumn(name = &quot;classes_id&quot;)//表示Student表中指向本表外键名</span><br><span class="line">    private List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###学生类(Student)</p><blockquote><p>学生代码 代表多的一方</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Student &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line">    @Column(nullable = false,unique = true)</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><blockquote><p> 测试代码：保存班级的同时保存学生ClassesRepository和StudentRepository此处省略..直接继承JpaRepository即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void saveTest()&#123;</span><br><span class="line">/*创建班级*/</span><br><span class="line">    Classes bj = new Classes();</span><br><span class="line">    bj.setName(&quot;一年级二班&quot;);</span><br><span class="line">    /*创建学生*/</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setName(&quot;小明&quot;);</span><br><span class="line">    Student stu2 = new Student();</span><br><span class="line">    stu2.setName(&quot;小红&quot;);</span><br><span class="line">    </span><br><span class="line">/*将学生添加到班级中*/</span><br><span class="line">    ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">    students.add(stu1);</span><br><span class="line">    students.add(stu2);</span><br><span class="line">    bj.setStudents(students);</span><br><span class="line">    </span><br><span class="line"> //保存班级,同时会级联保存学生</span><br><span class="line">    classesRepository.save(bj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生成表的SQL</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: create table classes (id integer not null auto_increment, name varchar(255), primary key (id))</span><br><span class="line">Hibernate: create table student (id integer not null auto_increment, name varchar(255), class_id integer, primary key (id))</span><br><span class="line">Hibernate: alter table student add constraint FK5v50ed2bjh60n1gc7ifuxmgf4 foreign key (class_id) references classes (id)</span><br></pre></td></tr></table></figure><blockquote><p>插入数据的SQL</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: insert into classes (name) values (?)</span><br><span class="line">Hibernate: insert into student (name) values (?)</span><br><span class="line">Hibernate: insert into student (name) values (?)</span><br><span class="line">Hibernate: update student set class_id=? where id=?</span><br><span class="line">Hibernate: update student set class_id=? where id=?</span><br></pre></td></tr></table></figure><h2 id="8-多对一关系-ManyToOne"><a href="#8-多对一关系-ManyToOne" class="headerlink" title="8.多对一关系(ManyToOne)"></a>8.多对一关系(ManyToOne)</h2><p>继续修改刚才的代码，在多的一方添加@ManyToOne</p><p>这里只需要在Student类中添加属性private Classes classes;生成get/set方法即可,并且在该属性上添加@ManyToOne(cascade={CascadeType.ALL})</p><blockquote><p>CascadeType.ALL表示级联删除，级联更新，级联新建，级联新建，比如删除主表，则从表也随之删除，详情见附录</p></blockquote><p>###学生类(Student)</p><blockquote><p>修改学生代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Student &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line">    @Column(nullable = false,unique = true)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(cascade=&#123;CascadeType.ALL&#125;)</span><br><span class="line">    private Classes classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###测试代码</p><blockquote><p>测试代码:查询所有学生对应的班级</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQuery()&#123;</span><br><span class="line">    List&lt;Student&gt; students = studentRepository.findAll();</span><br><span class="line">    for(Student student: students)&#123;</span><br><span class="line">        System.out.println(student.getClasses().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###可能遇到的异常</p><p>​    在controller返回数据到统一json转换的时候，出现了json infinite recursion stackoverflowerror的错误</p><p>​    具体的情况如下：</p><p>​    Classes类中，有个属性：private List<student> students;， Classes与Student的关系为 OneToMany；在Student类中，有属性private Classes classes;,引用到Classes中的字段id，并作为外键。hibernate查询结果正常，可以看到返回的Classes对象中，有Student参数值，但在json转换的时候就出现了无限递归的情况。原因是json在序列化Classes中的students属性的时候，找到了Student类，然后序列化Student类，而Student类中有classes属性，因此，为了序列化classes属性，json又得去序列化Classes类，如此递归反复，造成该问题。</student></p><p><strong>解决方法：</strong></p><p>​    在Student类中classes的setter方法上加注解@JsonBackReference</p><h2 id="9-多对多关系-ManyToMany"><a href="#9-多对多关系-ManyToMany" class="headerlink" title="9.多对多关系(ManyToMany)"></a>9.多对多关系(ManyToMany)</h2><p>以书和作者为例：</p><p>​    书(book)和作者(publisher)的可以看作多对多的关系，多对多关系需要一张中间表(book_publisher)来维护关系</p><p>关系图：</p><p><img src="//haoyongliang.gitee.io/2019/06/25/SpringBoot-master/03.SpringDataJPA使用/SpringDataJPA使用/many-to-many.png" alt="0"></p><p>###书类(Book)</p><blockquote><p>@JoinTable会生成第三张中间表,表名叫book_publisher,joinColumns表示当前实体(Book)的主键,inverseJoinColumns表示另一个实体(Publisher)的主键</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author:haoyongliang</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: created in 14:34 2018/5/22</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class Book&#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private int id;</span><br><span class="line">    @Column</span><br><span class="line">    private String name;</span><br><span class="line">    @ManyToMany(cascade = CascadeType.ALL)</span><br><span class="line">    @JoinTable(</span><br><span class="line">            name = &quot;book_publisher&quot;,</span><br><span class="line">            joinColumns = @JoinColumn(name = &quot;book_id&quot;,referencedColumnName = &quot;id&quot;),</span><br><span class="line">            inverseJoinColumns = @JoinColumn(name = &quot;publisher_id&quot;, referencedColumnName = &quot;id&quot;))</span><br><span class="line">    private Set&lt;Publisher&gt; publishers = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Book() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Book(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Book(String name, Set&lt;Publisher&gt; publishers)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.publishers = publishers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //TODO 省略GETTER/SETTER</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        String result = String.format(</span><br><span class="line">                &quot;Book [id=%d, name=&apos;%s&apos;]%n&quot;,</span><br><span class="line">                id, name);</span><br><span class="line">        if (publishers != null) &#123;</span><br><span class="line">            for(Publisher publisher : publishers) &#123;</span><br><span class="line">                result += String.format(</span><br><span class="line">                        &quot;Publisher[id=%d, name=&apos;%s&apos;]%n&quot;,</span><br><span class="line">                        publisher.getId(), publisher.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###作者类(Publisher)</p><blockquote><p>mappedBy = “publishers”表示关系由另一个实体(Book)维护，mappedBy 的值是Book类中的Set<book>属性的名字</book></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author:haoyongliang</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: created in 14:35 2018/5/22</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class Publisher &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private int id;</span><br><span class="line">    @Column</span><br><span class="line">    private String name;</span><br><span class="line">    @ManyToMany(mappedBy = &quot;publishers&quot;)</span><br><span class="line">    private Set&lt;Book&gt; books = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Publisher()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Publisher(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Publisher(String name, Set&lt;Book&gt; books)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.books = books;</span><br><span class="line">    &#125;</span><br><span class="line">//TODO 省略GETTER/SETTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h3><blockquote><p>BookRepository和PublisherRepository直接继承JpaRepository即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author:haoyongliang</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: created in 15:08 2018/5/22</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@EntityScan(basePackages=&quot;cn.itcast.sprintBootDemo.domain&quot;)</span><br><span class="line">@EnableJpaRepositories(basePackages = &#123;&quot;cn.itcast.sprintBootDemo.repository&quot;&#125;)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class BookRepositoryTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookRepository bookRepository;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PublisherRepository publisherRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Transactional</span><br><span class="line">    public void findAll() throws Exception &#123;</span><br><span class="line">        Publisher luxun = new Publisher(&quot;鲁迅&quot;);</span><br><span class="line">        Publisher chenduxiu = new Publisher(&quot;陈独秀&quot;);</span><br><span class="line">        Publisher libai = new Publisher(&quot;李白&quot;);</span><br><span class="line"></span><br><span class="line">        Book book1 = new Book(&quot;SpringDataJpa&quot;);</span><br><span class="line">        book1.getPublishers().add(luxun);</span><br><span class="line"></span><br><span class="line">        Book book2 = new Book(&quot;基因传&quot;);</span><br><span class="line">        book2.getPublishers().add(chenduxiu);</span><br><span class="line">        book2.getPublishers().add(libai);</span><br><span class="line"></span><br><span class="line">        bookRepository.save(book1);</span><br><span class="line">        bookRepository.save(book2);</span><br><span class="line">        List&lt;Book&gt; books = bookRepository.findAll();</span><br><span class="line">        for (Iterator&lt;Book&gt; iterator = books.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">            Book book =  iterator.next();</span><br><span class="line">            System.out.println(book.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##10.一对一关系</p><p>以人和身份证为例,一个人(Person)对应一个(IDCard)，关系由人(Person)来维护</p><h3 id="人类-Person"><a href="#人类-Person" class="headerlink" title="人类(Person)"></a>人类(Person)</h3><p>因为关系由Person维护，所以这里使用@JoinColumn声明person表中外键的名字(外建名=另一个表的表名+”_”+另一个表的主键名)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import javax.persistence.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author:haoyongliang</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: created in 17:49 2018/5/22</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class Person &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private int id;</span><br><span class="line">    @Column</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    @OneToOne(cascade = CascadeType.ALL)</span><br><span class="line">    @JoinColumn(name = &quot;idCard_id&quot;)</span><br><span class="line">    private IDCard idCard;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //TODO 省略GETTER和SETTER</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###身份证类(IDCard)</p><blockquote><p>mappedBy = “idCard”表示关系由另一个实体(Person)维护，mappedBy 的值是Person类中的IDCard属性的名字</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import javax.persistence.*;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author:haoyongliang</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: created in 17:51 2018/5/22</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class IDCard &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private int id;</span><br><span class="line">    @Column(unique = true)</span><br><span class="line">    /**身份证号*/</span><br><span class="line">    private String no;</span><br><span class="line">    @Column</span><br><span class="line">    @Temporal(TemporalType.DATE)</span><br><span class="line">    /**有效期*/</span><br><span class="line">    private Date expiryDate;</span><br><span class="line">   </span><br><span class="line">    @OneToOne(mappedBy = &quot;idCard&quot;)</span><br><span class="line">    private Person person;</span><br><span class="line"></span><br><span class="line">    public IDCard() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IDCard(String no, Date expiryDate) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.expiryDate = expiryDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //TODO 省略GETTER和SETTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><blockquote><p>PersonRepository和IDCardRepository直接继承JpaRepository</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@EntityScan(basePackages=&quot;cn.itcast.sprintBootDemo.domain&quot;)</span><br><span class="line">@EnableJpaRepositories(basePackages = &#123;&quot;cn.itcast.sprintBootDemo.repository&quot;&#125;)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class PersonRepositoryTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonRepository personRepository;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    /**测试保存*/</span><br><span class="line">    public void add() throws Exception&#123;</span><br><span class="line">        IDCard idCard = new IDCard(&quot;14240xxxxxxxxxxx&quot;,new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;2030-09-09&quot;));</span><br><span class="line"></span><br><span class="line">        Person jack = new Person(&quot;Jack&quot;);</span><br><span class="line">        jack.setIdCard(idCard);</span><br><span class="line"></span><br><span class="line">        personRepository.save(jack);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    /**测试查询*/</span><br><span class="line">    public void query() &#123;</span><br><span class="line">        List&lt;Person&gt; all = personRepository.findAll();</span><br><span class="line">        for (Iterator&lt;Person&gt; iterator = all.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">            Person p =  iterator.next();</span><br><span class="line">            System.out.println(p.getIdCard().getNo());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote><p>为方便阅读,下面是本文涉及到的注解的相关说明,在阅读文章时对注解如有问题可以查阅此附录</p></blockquote><p>##@ManyToMany注解</p><p>BookRepository extends JpaRepository是属性或方法级别的注解，用于定义源实体与目标实体是多对多的关系。</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>targetEntity</td><td>Class</td><td><strong>源实体</strong>关联的<strong>目标实体</strong>类型，默认是该成员属性对应的集合类型的泛型的参数化类型。</td></tr><tr><td>mappedBy</td><td>String</td><td>用在双向关联中。如果关系是双向的，则需定义此参数（与 @JoinColumn互斥，如果标注了 @JoinColumn注解，不需要再定义此参数）。</td></tr><tr><td>cascade</td><td>CascadeType[]</td><td>定义<strong>源实体</strong>和关联的<strong>目标实体</strong>间的级联关系。当对<strong>源实体</strong>进行操作时，是否对关联的<strong>目标实体</strong>也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项）</td></tr><tr><td>fetch</td><td>FetchType</td><td>定义关联的<strong>目标实体</strong>的数据的加载方式。可选值：FetchType.LAZY（延迟加载，默认）FetchType.EAGER（立即加载）延迟加载：只有在第一次访问<strong>源实体</strong>关联的<strong>目标实体</strong>的时候才去加载。立即加载：在加载<strong>源实体</strong>数据的时候同时去加载好关联的<strong>目标实体</strong>的数据。</td></tr></tbody></table><h2 id="OneToOne注解"><a href="#OneToOne注解" class="headerlink" title="@OneToOne注解"></a>@OneToOne注解</h2><p>是属性或方法级别的注解，用于定义源实体与目标实体是一对一的关系。</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>targetEntity</td><td>Class</td><td><strong>源实体</strong>关联的<strong>目标实体</strong>类型，默认是该成员属性对应的类型，因此该参数通常可以缺省。</td></tr><tr><td>mappedBy</td><td>String</td><td>用在双向关联中。如果关系是双向的，只能有一方作为主体端，另一方则需声明此参数以表明将表间的这种关联关系转交给对方来维护。</td></tr><tr><td>cascade</td><td>CascadeType[]</td><td>定义<strong>源实体</strong>和关联的<strong>目标实体</strong>间的级联关系。当对<strong>源实体</strong>进行操作时，是否对关联的<strong>目标实体</strong>也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项）</td></tr><tr><td>fetch</td><td>FetchType</td><td>定义关联的<strong>目标实体</strong>的数据的加载方式。可选值：FetchType.LAZY（延迟加载）FetchType.EAGER（立即加载，默认）延迟加载：只有在第一次访问<strong>源实体</strong>关联的<strong>目标实体</strong>的时候才去加载。立即加载：在加载<strong>源实体</strong>数据的时候同时去加载好关联的<strong>目标实体</strong>的数据。</td></tr><tr><td>optional</td><td>boolean</td><td><strong>源实体</strong>关联的<strong>目标实体</strong>是否允许为 null，默认为 true。</td></tr><tr><td>orphanRemoval</td><td>boolean</td><td>当<strong>源实体</strong>关联的<strong>目标实体</strong>被断开（如给该属性赋予另外一个实例，或该属性的值被设为 null。被断开的实例称为孤值，因为已经找不到任何一个实例与之发生关联）时，是否自动删除断开的实例（在数据库中表现为删除表示该实例的行记录），默认为 false。</td></tr></tbody></table><h2 id="OneToMany注解"><a href="#OneToMany注解" class="headerlink" title="@OneToMany注解"></a>@OneToMany注解</h2><p>@OneToMany 是属性或方法级别的注解，用于定义源实体与目标实体是一对多的关系。</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>targetEntity</td><td>Class</td><td><strong>源实体</strong>关联的<strong>目标实体</strong>类型，默认是该成员属性对应的集合类型的泛型的参数化类型。</td></tr><tr><td>mappedBy</td><td>String</td><td>用在双向关联中。如果关系是双向的，则需定义此参数（与 @JoinColumn 互斥，如果标注了 @JoinColumn注解，不需要再定义此参数）。</td></tr><tr><td>cascade</td><td>CascadeType[]</td><td>定义<strong>源实体</strong>和关联的<strong>目标实体</strong>间的级联关系。当对<strong>源实体</strong>进行操作时，是否对关联的<strong>目标实体</strong>也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项）</td></tr><tr><td>fetch</td><td>FetchType</td><td>定义关联的<strong>目标实体</strong>的数据的加载方式。可选值：FetchType.LAZY（延迟加载，默认）FetchType.EAGER（立即加载）延迟加载：只有在第一次访问<strong>源实体</strong>关联的<strong>目标实体</strong>的时候才去加载。立即加载：在加载<strong>源实体</strong>数据的时候同时去加载好关联的<strong>目标实体</strong>的数据。</td></tr><tr><td>orphanRemoval</td><td>boolean</td><td>当<strong>源实体</strong>关联的<strong>目标实体</strong>被断开（如给该属性赋予另外一个实例，或该属性的值被设为 null。被断开的实例称为孤值，因为已经找不到任何一个实例与之发生关联）时，是否自动删除断开的实例（在数据库中表现为删除表示该实例的行记录），默认为 false。(如果用CascadeType.REMOVE设置则必须要调用delete()方法才会删除)</td></tr></tbody></table><h2 id="ManyToOne注解"><a href="#ManyToOne注解" class="headerlink" title="@ManyToOne注解"></a>@ManyToOne注解</h2><p>@ManyToOne 是属性或方法级别的注解，用于定义源实体与目标实体是多对一的关系。</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>targetEntity</td><td>Class</td><td><strong>源实体</strong>关联的<strong>目标实体</strong>类型，默认是该成员属性对应的类型，因此该参数通常可以缺省。</td></tr><tr><td>cascade</td><td>CascadeType[]</td><td>定义<strong>源实体</strong>和关联的<strong>目标实体</strong>间的级联关系。当对<strong>源实体</strong>进行操作时，是否对关联的<strong>目标实体</strong>也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项）</td></tr><tr><td>fetch</td><td>FetchType</td><td>定义关联的<strong>目标实体</strong>的数据的加载方式。可选值：FetchType.LAZY（延迟加载）FetchType.EAGER（立即加载，默认）延迟加载：只有在第一次访问<strong>源实体</strong>关联的<strong>目标实体</strong>的时候才去加载。立即加载：在加载<strong>源实体</strong>数据的时候同时去加载好关联的<strong>目标实体</strong>的数据。</td></tr><tr><td>optional</td><td>boolean</td><td><strong>源实体</strong>关联的<strong>目标实体</strong>是否允许为 null，默认为 true。</td></tr></tbody></table><h2 id="JoinTable注解"><a href="#JoinTable注解" class="headerlink" title="@JoinTable注解"></a>@JoinTable注解</h2><p>与 @Table 注解相类似，不同的是，@JoinTable 注解是用于定义关联表，它只能标注在实体类型的成员属性或方法上，常用于多对多或多对一的关联映射。如果没有声明，则使用该注解的默认值。</p><p>多对一时慎用，因为会生成第三张表</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>连接表的名称。</td></tr><tr><td>catalog</td><td>String</td><td>默认为数据库系统缺省的 catalog。</td></tr><tr><td>schema</td><td>String</td><td>默认为用户缺省的 schema。</td></tr><tr><td>joinColumns</td><td>JoinColumn[]</td><td>连接表中的外键列，通过使用 @JoinColumn 注解来声明，该外键参照<strong>源实体</strong>的主键。</td></tr><tr><td>inverseJoinColumns</td><td>JoinColumn[]</td><td>与 <code>joinColumns</code> 参数作用类似，只不过该外键参照的是<strong>目标实体</strong>的主键。</td></tr><tr><td>uniqueConstraints</td><td>UniqueConstraint[]</td><td>表的唯一约束（除了由 @Column 和 @JoinColumn注解指定的约束以及主键的约束之外的约束），通过使用 @UniqueConstraint注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的约束条件。</td></tr><tr><td>indexes</td><td>Index[]</td><td>表的索引，通过使用 @Index注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的索引。</td></tr><tr><td>foreignKey</td><td>ForeignKey</td><td>用于生成表时定义 <code>joinColumns</code> 参数的外键约束。</td></tr><tr><td>inverseForeignKey</td><td>ForeignKey</td><td>用于生成表时定义 <code>inverseJoinColumns</code> 参数的外键约束。</td></tr></tbody></table><p>##@JoinColumn注解</p><p>与 @Column 注解相类似，不同的是，@JoinColumn 注解是用于定义外键列，它只能标注在实体类型的成员属性或方法上，如果没有声明，则使用该注解的默认值。与 @Column 注解相类似，不同的是，@JoinColumn 注解是用于定义外键列，它只能标注在实体类型的成员属性或方法上，如果没有声明，则使用该注解的默认值。</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>外键列的名称，默认为：<code>属性的名称</code> + <code>_</code> + <code>属性对应的实体的主键列的名称</code>（Hibernate 映射列时，若遇到驼峰拼写，会自动添加 <code>_</code> 连接并将大写字母改成小写）。</td></tr><tr><td>unique</td><td>boolean</td><td>外键列的值是否是唯一的。这是 @UniqueConstraint 注解的一个快捷方式，实质上是在声明唯一约束。默认值为 false。</td></tr><tr><td>nullable</td><td>boolean</td><td>外键列的值是否允许为 null。默认为 true。</td></tr><tr><td>insertable</td><td>boolean</td><td>外键列是否包含在 <code>INSERT</code> 语句中，默认为 true。</td></tr><tr><td>updatable</td><td>boolean</td><td>外键列是否包含在 <code>UPDATE</code> 语句中，默认为 true。</td></tr><tr><td>columnDefinition</td><td>String</td><td>生成外键列的 DDL 时使用的 SQL 片段。默认使用推断的类型来生成 SQL 片段以创建此列。</td></tr><tr><td>table</td><td>String</td><td>外键列所属的表的名称。默认值：如果是外键 <code>@OneToOne</code> 或 <code>@ManyToOne</code> 关联，则为<strong>源实体</strong>的表的名称；如果是单向外键 <code>@OneToMany</code> 关系，则为<strong>目标实体</strong>的表的名称；如果是 <code>@ManyToMany</code>、<code>@OneToOne</code>、双向 <code>@ManyToOne</code>、双向 <code>@OneToMany</code> 关联，则为连接表的名称；</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/25/SpringBoot-master/02.web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/2019/06/25/SpringBoot-master/02.web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot技术栈-Spring-Boot-对-Web-开发的支持"><a href="#Spring-Boot技术栈-Spring-Boot-对-Web-开发的支持" class="headerlink" title="Spring Boot技术栈(Spring Boot 对 Web 开发的支持)"></a>Spring Boot技术栈(Spring Boot 对 Web 开发的支持)</h1><ul><li><p>本篇介绍 Spring Boot中spring-boot-starter-web 对 Web 开发的支持，主要包括 RestFul、获取请求参数、过滤器等功能。</p><p>注：spring-boot-starter-web 是一个用于构建 Web 的 Starter ，包括构建 RESTful 服务应用、Spring MVC 应用等。并且不需要额外配置容器，默认使用 Tomcat 作为嵌入式容器。</p></li></ul><h1 id="1-编写RestFul风格的代码"><a href="#1-编写RestFul风格的代码" class="headerlink" title="1.编写RestFul风格的代码"></a>1.编写RestFul风格的代码</h1><p> 在 Spring Boot 体系中，天然对 Json 支持。无论返回集合还是对象，Spring Boot 均可以将其转化为 Json 字符串，特别适合我们给其他系统提供接口时使用。</p><ol><li><p>在domain包下新建一个实体类 Person，Person 信息如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*@author haoyongliang</span><br><span class="line">*/</span><br><span class="line">public class Person &#123;</span><br><span class="line">  private String name;//姓名</span><br><span class="line">  private int age;//年龄</span><br><span class="line">  private String address;//住址</span><br><span class="line">  //省略无参、全参构造/getter、setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ​</p></li></ol><ol start="2"><li><p>在web包下新建一个类 PersonController ,PersonController 信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*@autor haoyongliang</span><br><span class="line">*/</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;personController&quot;)</span><br><span class="line">public class PersonController &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 演示返回一个集合对象的JSON数据，</span><br><span class="line">   * 访问方式 http://localhost:8080/personController/findAllPerson</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  @RequestMapping(&quot;findAllPerson&quot;)</span><br><span class="line">  public ArrayList&lt;Person&gt; findAllPerson()&#123;</span><br><span class="line">      ArrayList&lt;Person&gt; persons = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      persons.add(new Person(&quot;JACK&quot;,23,&quot;山西晋中榆次&quot;));</span><br><span class="line">      persons.add(new Person(&quot;ROSE&quot;,23,&quot;山西太原小店&quot;));</span><br><span class="line">      persons.add(new Person(&quot;ROBIN&quot;,23,&quot;山西阳泉&quot;));</span><br><span class="line"></span><br><span class="line">      return persons;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 演示返回一个实体类对象的JSON数据。</span><br><span class="line">   * 访问方式 http://localhost:8080/personController/findPerson</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  @RequestMapping(&quot;findPerson&quot;)</span><br><span class="line">  public Person findPerson()&#123;</span><br><span class="line">      return new Person(&quot;JACK&quot;,23,&quot;山西晋中榆次&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问 <a href="http://localhost:8080/personController/findAllPerson" target="_blank" rel="noopener">http://localhost:8080/personController/findAllPerson</a> 返回结果如下</p><p><img src="//haoyongliang.gitee.io/2019/06/25/SpringBoot-master/02.web开发实战/web开发实战/findAllStudent.jpg" alt="0"></p></li><li><p>访问 <a href="http://localhost:8080/personController/findPerson" target="_blank" rel="noopener">http://localhost:8080/personController/findPerson</a> 返回结果如下</p><p><img src="//haoyongliang.gitee.io/2019/06/25/SpringBoot-master/02.web开发实战/web开发实战/findStudent.jpg" alt="1"></p><p><strong>注：</strong> 浏览器中的返回结果看起来非常美观是因为使用了Google浏览器插件JSON-handle，安装方法参见<a href="https://jingyan.baidu.com/article/c910274bb4b659cd361d2dad.html" title="点此查看JSON-handle的安装方法" target="_blank" rel="noopener">https://jingyan.baidu.com/article/c910274bb4b659cd361d2dad.html</a></p></li></ol><h1 id="2-POST和GET传参-amp-参数校验"><a href="#2-POST和GET传参-amp-参数校验" class="headerlink" title="2.POST和GET传参&amp;参数校验"></a>2.POST和GET传参&amp;参数校验</h1><h2 id="1-POST-传参"><a href="#1-POST-传参" class="headerlink" title="1.POST 传参"></a>1.POST 传参</h2><ol><li><p>通过 @RequestMapping 注解的 method 属性指定请求方式为POST</p></li><li><p>给方法添加形式参数用于接收客户端请求发送过来的数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如果形式参数是Person类型，只要是 Person 的属性都会被自动填充到 person 对象中</span><br><span class="line"> * 访问路径http://localhost:8080/personController/showPersonInfo1</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(value = &quot;showPersonInfo1&quot;, method = RequestMethod.POST)</span><br><span class="line">public Person showPersonInfo(Person person)&#123;</span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 接收name，age，address参数并手动将其封装成Person对象</span><br><span class="line"> * 访问路径http://localhost:8080/personController/showPersonInfo2</span><br><span class="line"> * @</span><br><span class="line"> * m person</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(value = &quot;showPersonInfo2&quot;, method = RequestMethod.POST)</span><br><span class="line">public Person showPersonInfo(String name, int age, String address)&#123;</span><br><span class="line">    Person p = new Person(name,age,address);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ol><p>  <strong>注：</strong> 在使用第一种方式接受数据的时候<strong>Person类必须有一个无参构造</strong>，框架内部先通过无参构造创建对象，然后调用set方法赋值，最后将对象当作 <em>实际参数</em> 赋值给 <em>形式参数</em></p><h2 id="2-GET-传参"><a href="#2-GET-传参" class="headerlink" title="2.GET 传参"></a>2.GET 传参</h2><ol><li><p>@RequestMapping 注解的method属性默认就是GET请求，当然也可以手动指定</p></li><li><p>使用 @RequestParam 或者 @PathVariable 来接收参数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 访问路径http://localhost:8080/personController/getDetails/A1001?param1=&quot;美国&quot;¶m2=&quot;纽约&quot;</span><br><span class="line"> * @param id</span><br><span class="line"> * @param param1</span><br><span class="line"> * @param param2</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(&quot;/getDetails/&#123;id&#125;&quot;)</span><br><span class="line">public String getDetails(@PathVariable(value=&quot;id&quot;) String id,</span><br><span class="line">                         @RequestParam(value=&quot;param1&quot;, required=true) String param1,</span><br><span class="line">                         @RequestParam(value=&quot;param2&quot;, required=false) String param2)&#123;</span><br><span class="line"> </span><br><span class="line">    return &quot;访问成功:id=&quot;+id+&quot;,param1=&quot;+param1+&quot;,param2=&quot;+param2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   结果如下</p><p><img src="//haoyongliang.gitee.io/2019/06/25/SpringBoot-master/02.web开发实战/web开发实战/getDetails.jpg" alt="1"></p></li></ol><ul><li><p><strong>@RequestParam</strong>和<strong>@PathVariable</strong>注解的作用</p><ul><li><p>@RequestParam 和 @PathVariable 两个都可以接收参数.@RequestParam是从请求中获取数据，也就是获取URL中?后面的数据。而@PathVariable则是获取URL地址中的一部分值。</p></li><li><p><strong>@RequestParam</strong> 支持下面四种参数</p><ol><li>defaultValue 如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值</li><li>name 绑定本次参数的名称，要跟URL上面的一样</li><li>required 这个参数是不是必须的</li><li>value 跟name一样的作用，是name属性的一个别名 </li></ol><ul><li><strong>建议：</strong>作为一种最佳实践，几乎所有开发人员都在按照以下方式推荐。如果你想识别资源，你应该使用路径变量。但是如果你想排序或过滤项目，那么你应该使用查询参数。</li></ul></li></ul></li></ul><h2 id="3-参数校验"><a href="#3-参数校验" class="headerlink" title="3.参数校验"></a>3.参数校验</h2><p> 参数校验在我们日常开发中非常常见，最基本的校验有判断属性是否为空、长度是否符合要求等，在传统的开发模式中需要写一堆的 if else 来处理这些逻辑，很繁琐，效率也低。使用 @Valid + BindingResult 就可以优雅地解决这些问题，接下来看看示例：</p><ol><li><p>首先在 PersonController 添加一个保存用户的方法 savePerson，参数为 Person，现在需要对参数 Person  做校验：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    @NotEmpty(message=&quot;姓名不能为空&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Max(value = 100,message = &quot;年龄不能大于100&quot;)</span><br><span class="line">    @Min(value = 1,message = &quot;年龄不能小于1&quot;)</span><br><span class="line">    private int age;</span><br><span class="line">    @Length(message = &quot;地址长度应该在7-10个汉字之间&quot;,min = 14,max=20)</span><br><span class="line">    @NotEmpty(message = &quot;地址不能为空&quot;)</span><br><span class="line">    private String address;</span><br><span class="line">    //省略无参、全参构造/getter、setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ​</p></li><li><p>Spring Boot 的参数校验其实是依赖于 hibernate-validator 来进行。现在模拟对参数 User 进行参数校验，使用 @Valid + BindingResult，校验后如果有错误将错误打印出来，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;savePerson&quot;)</span><br><span class="line">public String savePerson(@Valid Person person, BindingResult result)&#123;</span><br><span class="line">    String message = &quot;&quot;;</span><br><span class="line">    if(result.hasErrors())&#123;</span><br><span class="line">        List allErrors = result.getAllErrors();</span><br><span class="line">        for (ObjectError error : allErrors) &#123;</span><br><span class="line">            message += error.getDefaultMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if(message==&quot;&quot;)&#123;</span><br><span class="line">        message = &quot;添加成功&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>访问<a href="http://localhost:8080/personController/savePerson，结果如下" target="_blank" rel="noopener">http://localhost:8080/personController/savePerson，结果如下</a></p><p><img src="//haoyongliang.gitee.io/2019/06/25/SpringBoot-master/02.web开发实战/web开发实战/valid.jpg" alt="1"></p><ol start="4"><li><strong>附：</strong>java校验api所提供的校验注解</li></ol><ul><li>@AssertFalse 所注解的元素必须为 boolean类型,并且值为 false</li><li>@AssertTrue 所注解的元素必须为 boolean类型,并且值为 true</li><li>Digits 所注解的元素必须是数字,并且它的值必须有指定的位数</li><li>Future 所注解的值必须是一个将来的日期</li><li>Past 所注解的值必须是一个已经过去的日期</li><li>Min 所注解的元素必须是数字,并且它的值必须小于等于给定的值</li><li>Max 所注解的元素必须是数字,并且它的值必须大于等于给定的值</li><li>NotNull 所注解的元素不能为null</li><li>NotEmpty 所注解元素不能为 空(注意不是null)</li><li>Null 做注解的元素必须为null</li><li>Size 所注解的元素必须是String,集合,或数组,并且它的长度要符合给定的范围</li><li>Pattern 所注解的元素的值必须匹配给定的正则表达式</li></ul></li></ol><h1 id="3-自定义过滤器"><a href="#3-自定义过滤器" class="headerlink" title="3.自定义过滤器"></a>3.自定义过滤器</h1><h2 id="1-过滤器功能"><a href="#1-过滤器功能" class="headerlink" title="1. 过滤器功能"></a>1. 过滤器功能</h2><p> 过滤器可以用于记录请求日志、排除有 XSS 威胁的字符、执行权限验证等等</p><h2 id="2-自定义过滤器步骤"><a href="#2-自定义过滤器步骤" class="headerlink" title="2. 自定义过滤器步骤"></a>2. 自定义过滤器步骤</h2><ol><li><p>创建一个类实现 javax.servlet.Filter 接口</p></li><li><p>将创建的类挂载到过滤器链上</p><p>a. 创建MyFilter类实现Filter接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        //打印请求Url</span><br><span class="line">        System.out.println(&quot;当前客户端正在请求访问的路径是:&quot; + req.getRequestURI());</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> b. 通过@Configuration + @Bean 注解将过滤器注入到 IOC 容器中，并通过 setOrder 方法设置过滤器位置（过滤器链中的位置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyFilterConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean myFilterRegistration() &#123;</span><br><span class="line">        FilterRegistrationBean registration = new FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(new MyFilter());//添加过滤器</span><br><span class="line">        registration.addUrlPatterns(&quot;/*&quot;);//设置过滤路径，/*所有路径</span><br><span class="line">        registration.addInitParameter(&quot;name&quot;, &quot;alue&quot;);//添加默认参数</span><br><span class="line">        registration.setName(&quot;MyFilter&quot;);//设置优先级</span><br><span class="line">        registration.setOrder(1);//设置优先级</span><br><span class="line">        return registration;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. 重新启动项目,访问任意一个服务，会发现在控制台中都会打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前客户端正在请求访问的路径是:....</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-Configuration和-Bean注解说明"><a href="#3-Configuration和-Bean注解说明" class="headerlink" title="3. @Configuration和@Bean注解说明:"></a>3. <strong>@Configuration和@Bean注解说明:</strong></h2><ol><li><p>@Configuration 标注在类上，相当于把该类作为spring的xml配置文件中的 &lt;beans&gt;，作用为：配置spring容器(应用上下文),上文中在MyFilterConfiguration类上添加了该注解，相当于创建了一个beans.xml配置文件里面的内容是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;  </span><br><span class="line">xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd </span><br><span class="line">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</span><br><span class="line">http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd</span><br><span class="line">http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd</span><br><span class="line">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span><br><span class="line">http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd</span><br><span class="line">http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd&quot; default-lazy-init=&quot;false&quot; &gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>@Bean标注在方法上(返回某个实例的方法)，等价于spring的xml配置文件中的&lt;bean&gt;，作用为：注册bean对象。</p><ul><li><p>@Bean注解在返回实例的方法上，如果未通过@Bean指定bean的名称，则默认与标注的方法名相同。</p></li><li><p>@Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域</p><p>上文中在myFilterRegistration()方法上加了@Bean注解，表示在spring启动的时候会执行该方法并将结果作为一个bean注册到容器中，该bean的名字是”myFilterRegistration”</p></li></ul></li></ol><h1 id="4-属性配置和自定义属性配置"><a href="#4-属性配置和自定义属性配置" class="headerlink" title="4.属性配置和自定义属性配置"></a>4.属性配置和自定义属性配置</h1><p>  如果需要修改自定义修改默认配置，spring boot 提供了很简便的方法，只需要在application.properties 中添加修改相应的配置。（spring boot启动的时候会读取application.properties这份默认配置）</p><h2 id="1-属性配置"><a href="#1-属性配置" class="headerlink" title="1.属性配置"></a>1.属性配置</h2><p>  例如 : spring boot 开发web应用的时候，默认tomcat的启动端口为8080，如果需要修改默认的端口，则需要在application.properties 添加以下记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8888</span><br></pre></td></tr></table></figure><p>重启项目，启动日志可以看到：Tomcat started on port(s): 8888 (http) 启动端口为8888，浏览器中访问 <a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a> 能正常访问。</p><h2 id="2-自定义属性配置"><a href="#2-自定义属性配置" class="headerlink" title="2.自定义属性配置"></a>2.自定义属性配置</h2><p>  在application.properties中除了可以修改默认配置，我们还可以在这配置自定义的属性，并在实体bean中加载出来。</p><ol><li><p>在application.properties中添加自定义属性配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cn.itcast.username = LuRenJia</span><br><span class="line">cn.itcast.password = admin</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>编写Bean类，加载属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;cn.itcast&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">   private String username;</span><br><span class="line">   private String password;</span><br><span class="line"> </span><br><span class="line">   //省略getter/setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引入ConfigurationProperties注解的时候会报错，需要添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写控制器看看是否将数据成功加载到User中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;userController&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private User user;</span><br><span class="line"> </span><br><span class="line">   @RequestMapping(value = &quot;info&quot;,method = RequestMethod.GET)</span><br><span class="line">   public String info()&#123;</span><br><span class="line">       return user.getUsername()+&quot;,&quot;+user.getPassword();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>访问<a href="http://localhost:8080/userController/info" target="_blank" rel="noopener">http://localhost:8080/userController/info</a> 查看结果，在页面显示如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LuRenJia,admin</span><br></pre></td></tr></table></figure><p>如果测试中出现中文乱码，可安装以下方法进行设置：</p><p>依次单击 File =&gt; Settings =&gt; Editor =&gt; File Encodings 命令，将 Properties Files (*.properties) 下的 Default encoding for properties files 设置为 UTF-8，将 Transparent native-to-ascii conversion 前的复选框勾选上。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/25/SpringBoot-master/01.%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSpringBoot/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSpringBoot/"/>
      <url>/2019/06/25/SpringBoot-master/01.%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSpringBoot/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot技术栈-快速上手SpringBoot"><a href="#Spring-Boot技术栈-快速上手SpringBoot" class="headerlink" title="Spring Boot技术栈(快速上手SpringBoot)"></a>Spring Boot技术栈(快速上手SpringBoot)</h1><ul><li>本篇带大家搭建开发环境，感受SpringBoot快速开发带来的好处</li></ul><h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><p>Spring Boot 是一套全新的框架，它来自于 Spring 大家族，因此 Spring 所有具备的功能它都有，而且更容易使用；Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，<strong>多数 Spring Boot 应用只需要很少的 Spring 配置</strong>。Spring Boot 开发了很多的应用集成包，支持绝大多数开源软件，让我们以很低的成本去集成其他主流开源软件。</p><p>Spring Boot 所集成的技术栈，几乎都是各互联网公司在使用的技术，按照 Spring Boot 的路线去学习，基本可以了解国内外互联网公司的技术特点。</p><p>Spring Boot 和微服务架构都是未来软件开发的一个大趋势，越早参与其中受益越大。</p><h2 id="1-开发环境搭建"><a href="#1-开发环境搭建" class="headerlink" title="1.开发环境搭建"></a>1.开发环境搭建</h2><h3 id="1-创建和导入项目"><a href="#1-创建和导入项目" class="headerlink" title="1.创建和导入项目"></a>1.创建和导入项目</h3><ol><li>访问 <a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a></li><li>选择构建工具 Maven Project、Spring Boot 版本 1.5.8 及一些工程基本信息，可参考下图：<br><img src="//haoyongliang.gitee.io/2019/06/25/SpringBoot-master/01.快速上手SpringBoot/快速上手SpringBoot/gouJianXiangMu.jpg" alt="0"></li><li>单击 Generate Project 按钮并下载项目压缩包。</li><li>这里使用的是 Idea，单击 File | New | Model from Existing Source.. | 选择解压后的文件夹 | OK 命令， 选择 Maven ，一路 Next，OK Done!</li></ol><h4 id="对上面的配置做一个解释"><a href="#对上面的配置做一个解释" class="headerlink" title="对上面的配置做一个解释"></a>对上面的配置做一个解释</h4><ul><li>第一个选择框选择创建以 Maven 构建项目，还是以 Gradle 构建项目，这是两种不同的构建方式，其中 Gradel 配置内容更简洁一些，并且包含了 Maven 的使用，不过日常使用 Maven 居多。</li><li>第二个选择框选择编程语言，现在支持 Java、Kotlin 和 Groovy。</li><li>第三个选择框选择 Spring Boot 版本，可以看出 Spring Boot 2.0 已经到了第五个里程碑了。在实际使用中，我们会优先使用稳定版本，1.0 的最新稳定版本是 1.5.8，也是我们演示使用的版本。</li></ul><h4 id="下面就是项目的配置信息了。"><a href="#下面就是项目的配置信息了。" class="headerlink" title="下面就是项目的配置信息了。"></a>下面就是项目的配置信息了。</h4><ul><li>Group：一般填写公司域名，比如传智播客填 cn.itcast</li><li>Artifact：可以理解为项目的名称，可以根据实际情况来填，本次演示填写 springBootDemo。</li><li>Dependencies：在这块添加我们项目所依赖的 Spring Boot 组件，可以多选。本次选择 Web、devtools 两个模块。</li></ul><h3 id="2-项目结构介绍"><a href="#2-项目结构介绍" class="headerlink" title="2.项目结构介绍"></a>2.项目结构介绍</h3><p>Spring Boot 的基础结构共三个文件：</p><p><img src="//haoyongliang.gitee.io/2019/06/25/SpringBoot-master/01.快速上手SpringBoot/快速上手SpringBoot/mulujiegou.jpg" alt="1"></p><ul><li>src/main/java：程序开发以及主程序入口</li><li>src/main/resources：配置文件</li><li>src/test/java：测试程序</li></ul><h3 id="3-Sping-Boot-建议的包结构"><a href="#3-Sping-Boot-建议的包结构" class="headerlink" title="3.Sping Boot 建议的包结构"></a>3.Sping Boot 建议的包结构</h3><p>root package 结构：cn.giftsstore.myProject</p><pre>myproject +-src    +- main         +- java              +- cn.giftsstore.myProject                    +- comm                    +- domain                    +- repository                    +- service                    +- web                    +- Application.java         +- resources              +- static              +- templates              +- application.properties    +- test +-pom.xml</pre><h3 id="4-各包名介绍"><a href="#4-各包名介绍" class="headerlink" title="4.各包名介绍"></a>4.各包名介绍</h3><ul><li><p>Application.java：建议放到根目录下面，是项目的启动类，Spring Boot 项目只能有一个 main() 方法。</p></li><li><p>comm：目录建议放置公共的类，如全局的配置文件、工具类等。</p></li><li><p>domain：目录主要用于实体（Entity）与数据访问层（Repository）。</p></li><li><p>repository：数据库访问层代码。</p></li><li><p>service：该层主要是业务类代码。</p></li><li><p>web：该层负责页面访问控制。</p></li><li><p>resources 目录下：</p><ul><li>static：目录存放 Web 访问的静态资源，如 JS、CSS、图片等。</li><li>templates：目录存放页面模板。</li><li>application.properties：项目的配置信息。</li><li>test 目录存放单元测试的代码；pom.xml 用于配置项目依赖包，以及其他配置。</li></ul></li></ul><p>采用默认配置可以省去很多设置，当然也可以根据自己的喜好来进行更改。最后，启动 Application main 方法，至此一个 Java 项目搭建好了！</p><h2 id="2-简单-Web-开发"><a href="#2-简单-Web-开发" class="headerlink" title="2.简单 Web 开发"></a>2.简单 Web 开发</h2><h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h3><p> 可以在 Spring Initializr 上面添加，也可以手动在 pom.xml 中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>pom.xml 文件中默认有两个模块：<ul><li>spring-boot-starter：核心模块，包括自动配置支持、日志和 YAML；</li><li>spring-boot-starter-test：测试模块，包括 JUnit、Hamcrest、Mockito。</li></ul></li></ul><h3 id="2-编写控制层-controller-代码"><a href="#2-编写控制层-controller-代码" class="headerlink" title="2.编写控制层(controller)代码"></a>2.编写控制层(controller)代码</h3><pre>@RestControllerpublic class HelloWorldController {    @RequestMapping("/hello")    public String hello() {        return "Hello World";    }}</pre><p>@RestController 的意思就是 controller 里面的方法都以 json 格式输出，不用再配置什么 jackjson 的了！</p><p>如果配置为@Controller 就代表着输出为页面内容。</p><h3 id="3-查看运行结果"><a href="#3-查看运行结果" class="headerlink" title="3.查看运行结果"></a>3.查看运行结果</h3><p> 启动主程序，打开浏览器访问 <a href="http://localhost:8080/hello，就可以看到以下内容，是不是很简单！" target="_blank" rel="noopener">http://localhost:8080/hello，就可以看到以下内容，是不是很简单！</a></p><pre>Hello World</pre><h3 id="4-URL传参"><a href="#4-URL传参" class="headerlink" title="4.URL传参"></a>4.URL传参</h3><blockquote><p>这里仅仅做一个简单传参,第二章会详细介绍如何传参</p></blockquote><pre>@RestControllerpublic class HelloWorldController {    @RequestMapping("/hello")    public String index(String name) {        return "Hello World, " +name;    }}</pre><p>重新启动项目，访问 <a href="http://localhost:8080/hello?name=neo，返回内容如下：" target="_blank" rel="noopener">http://localhost:8080/hello?name=neo，返回内容如下：</a></p><pre>Hello World，neo</pre><p>经过上一个测试发现，修改 controller 内相关代码，就需要重新启动项目才能生效，这样做很麻烦是不是，别着急。Spring Boot 提供了另外一个组件来解决。</p><h2 id="3-热部署"><a href="#3-热部署" class="headerlink" title="3.热部署"></a>3.热部署</h2><p>热启动就需要用到我们在一开始引入的另外一个组件：devtools。它是 Spring Boot 提供的一组开发工具包，其中就包含我们需要的热部署功能。但是在使用这个功能之前还需要再做一些配置。</p><ol><li><p>在 dependency 中添加 optional 属性，并设置为 true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-Devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>在 plugin 中配置另外一个属性 fork，并且配置为 true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置 Idea</p><ol><li>选择 File-Settings-Compiler 勾选 Build project automatically，低版本 Idea 勾选 make project automatically。<br><img src="//haoyongliang.gitee.io/2019/06/25/SpringBoot-master/01.快速上手SpringBoot/快速上手SpringBoot/ideahot.jpg" alt="2"></li><li>使用快捷键：CTRL + SHIFT + A 输入Registry 找到选项 compile.automake.allow.when.app.running 勾选<br><img src="//haoyongliang.gitee.io/2019/06/25/SpringBoot-master/01.快速上手SpringBoot/快速上手SpringBoot/0.6294533078536897.png" alt="3"></li></ol><p>全部配置完成后，Idea 就支持热部署了，大家可以试着去改动一下代码就会发现 Spring Boot 会自动重新加载，再也不需要我们手动点击重新部署了。</p></li></ol><p>为什么 Idea 需要多配置后面这一步呢，因为 Idea 默认不是自动编译的，需要我们手动去配置后才会自动编译，而热部署依赖于项目的自动编译功能。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/25/SpringBoot-master/SUMMARY/"/>
      <url>/2019/06/25/SpringBoot-master/SUMMARY/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot技术栈"><a href="#SpringBoot技术栈" class="headerlink" title="SpringBoot技术栈"></a>SpringBoot技术栈</h2><ul><li><a href="README.md">前沿</a></li><li><a href="01.快速上手SpringBoot/快速上手SpringBoot.md">第一章 快速上手SpringBoot</a></li><li><a href="02.web开发实战/web开发实战.md">第二章 web开发实战</a></li><li><a href="03.SpringDataJPA使用/SpringDataJPA使用.md">第三章 SpringDataJPA使用</a></li><li><a href="README.md">未完待续..</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/25/SpringBoot-master/README/"/>
      <url>/2019/06/25/SpringBoot-master/README/</url>
      
        <content type="html"><![CDATA[<h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h1><h2 id="作者-郝永亮"><a href="#作者-郝永亮" class="headerlink" title="作者:郝永亮"></a>作者:郝永亮</h2><h2 id="联系方式-haoyongliang-foxmail-com"><a href="#联系方式-haoyongliang-foxmail-com" class="headerlink" title="联系方式:haoyongliang@foxmail.com"></a>联系方式:<a href="mailto:haoyongliang@foxmail.com" target="_blank" rel="noopener">haoyongliang@foxmail.com</a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot</title>
      <link href="/2019/06/24/springboot/"/>
      <url>/2019/06/24/springboot/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/23/hello-world/"/>
      <url>/2019/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
  
</search>
